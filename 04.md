HELLO RECURSION!

در این فصل، به مطالعه بازگشتی ها `(Recursion)` خواهیم پرداخت. در اینجا خواهیم آموخت که چرا بازگشتی ها در برنامه نویسی `Haskell` مهم هستند و چگونه می توانیم با تفکر بازگشتی به راه حل های بسیار مختصر و شیک دست پیدا کنیم.

تابع بازگشتی یک تابع است که در داخل تعریف خود فراخوانی می‌شود. به عبارت دیگر، این تابع خودش را صدا می‌زند. اگر هنوز نمی‌دانید بازگشتی چیست، جمله قبلی را بخوانید (هاها! شوخی کردم!)
اما حالا وقت شوخی‌ها به پایین آمده است، استراتژی یک تابع بازگشتی برای حل یک مسئله، تجزیه آن به مسائل کوچک‌تری از همان نوع است و سپس تلاش برای حل آن زیرمسائل است. در صورت لزوم، این زیرمسائل نیز بازتجزیه می‌شوند.
در نهایت، به حالت پایه (یا حالات پایه) مسئله می‌رسیم که دیگر نمی‌توان آن را تجزیه کرد و راه‌حل‌های آن باید به صورت صریح (غیربازگشتی) توسط برنامه‌نویس تعریف شوند.

 تعاریف در ریاضیات اغلب بازگشتی هستند. به عنوان مثال، ما می‌توانیم دنباله فیبوناچی را به صورت بازگشتی به شرح زیر مشخص کنیم: ابتدا دو عدد اول دنباله فیبوناچی را به صورت مستقیم تعریف می‌کنیم و می‌گوییم که F (0) = 0 و F (1) = 1، به این معنی که عدد صفرم و یکم دنباله فیبوناچی به ترتیب 0 و 1 هستند. اینها موارد پایه ما هستند.

سپس ما مشخص می‌کنیم که برای هر عدد طبیعی به جز 0 و 1، عدد فیبوناچی متناظر با جمع دو عدد قبلی دنباله فیبوناچی است. به عبارت دیگر، F (n) = F (n - 1) + F (n - 2). به عنوان مثال، F (3) برابر با F (2) + F (1) است که به ترتیب به (F (1) + F (0)) + F (1) تجزیه می‌شود. به دلیل آنکه ما به عدد فیبوناچی غیر بازگشتی رسیدیم، می‌توانیم با اطمینان بگوییم که مقدار F (3) برابر با 2 است.
بازگشتی در Haskell به دلیل اینکه در مقابل زبان‌های امپراتیو، محاسبات را در Haskell با اعلام آنچه چیزی است، بجای مشخص کردن چگونگی محاسبه آن، انجام می‌دهیم، بسیار مهم است. به همین دلیل، Haskell درباره ارائه توالی گام‌های اجرایی به کامپیوتر شما نیست، بلکه درباره تعریف مستقیم نتیجه موردنظر است، اغلب به صورت بازگشتی.


Maximum Awesome

بیایید یک تابع موجود در Haskell را بررسی کنیم و ببینیم چگونه می‌توانیم خودمان تابع را با استفاده از بازگشتی پیاده‌سازی کنیم. تابع maximum یک لیستی از چیزهایی که می‌توانند مرتب شوند (به عنوان مثال، نمونه‌های کلاس نوع Ord) را دریافت می‌کند و بزرگترین آنها را بازمی‌گرداند. این تابع با استفاده از بازگشتی بسیار شیک و زیبا قابل بیان است. قبل از بحث در مورد یک راه‌حل بازگشتی، فکر کنید که چگونه می‌توانید تابع maximum را به صورت امپراتیو پیاده‌سازی کنید؟ شاید یک متغیر را برای نگهداری مقدار بیشینه فعلی تعریف کنید، سپس به ازای هر عنصر در لیست حلقه را اجرا کنید. اگر عنصر فعلی بزرگتر از مقدار بیشینه فعلی باشد، مقدار بیشینه را با آن جایگزین می‌کنید. مقدار بیشینه که در پایان حلقه باقی می‌ماند، نتیجه نهایی خواهد بود. حالا بیایید ببینیم چگونه می‌توانیم آن را به صورت بازگشتی تعریف کنیم. ابتدا، ما باید مورد پایه را تعریف کنیم: ما می‌گوییم که بیشینه یک لیست تک عنصری برابر با تنها عنصر آن است. اما اگر لیست بیش از یک عنصر داشته باشد، چه؟ خب، در این صورت باید بررسی کنیم کدامیک بزرگتر است: عنصر اول (سر) یا بیشینه بقیه لیست (دم). کد برای تابع بازگشتی maximum' به شرح زیر است:

```
maximum' :: (Ord a) => [a] -> a
maximum' [] = error "maximum of empty list!"
maximum' [x] = x
maximum' (x:xs) = max x (maximum' xs)
```

همانطور که در اینجا مشاهده می‌کنید، الگوگیری (Pattern Matching) برای تعریف توابع بازگشتی بسیار مفید است. قابلیت هم‌خوانی و بازسازی مقادیر باعث می‌شود که پیدا کردن حداکثر (maximum) در لیست به راحتی به موارد مربوط و زیرمسئله‌های بازگشتی تقسیم شود. الگوی اول می‌گوید که اگر لیست خالی باشد، برنامه باید خراب شود. این مفهومی است که ما نمی‌توانیم بگوییم حداکثر یک لیست خالی چیست. الگوی دوم می‌گوید که اگر تابع maximum' به یک لیست با یک عضو فراخوانی شود، باید فقط عضو این لیست را بازگرداند.

الگوی سوم ما مرحله اصلی بازگشت است. لیست به دو قسمت سر و دم تقسیم می‌شود. سر را x و دم را xs نامگذاری می‌کنیم. سپس از دوست قدیمی ما، تابع max استفاده می‌کنیم. تابع max دو چیز را می‌گیرد و بزرگترین آن‌ها را برمی‌گرداند. اگر x بزرگتر از بزرگترین عضو xs باشد، تابع ما x را برمی‌گرداند، در غیر این صورت بزرگترین عضو xs را برمی‌گرداند. اما چگونه maximum' ما بزرگترین عضو xs را پیدا می‌کند؟ ساده است - با فراخوانی خودش به صورت بازگشتی!

در اینجا، با یک مثال خاص به بررسی این کد می‌پردازیم تا در صورتی که با کارکرد maximum' مشکل دارید، بهتر متوجه شوید. در این مثال، اگر maximum' را روی [2، 5، 1] فراخوانی کنیم، دو الگوی اول با فراخوانی تابع مطابقت ندارند. با این حال، الگوی سوم مطابقت دارد، بنابراین مقدار لیست به 2 و [5،1] تقسیم شده و maximum' با [5،1] فراخوانی می‌شود. در این فراخوانی جدید maximum'، [5،1] با الگوی سوم مطابقت دارد و دوباره لیست ورودی تقسیم می‌شود - این بار به 5 و [1] - و maximum' به صورت بازگشتی روی [1] فراخوانی می‌شود. این یک لیست یک عضوی است، بنابراین تماس جدیدتر اکنون با یکی از موارد پایه ما مطابقت دارد و به عنوان نتیجه 1 بازگردانده می‌شود. حال به سطح بالاتر برمی‌گردیم و با استفاده از تابع max، 5 را با 1 مقایسه می‌کنیم. 1 نتیجه تماس بازگشتی ما بود. از آنجا که 5 بزرگتر است، حالا می‌دانیم که بیشینه [5،1] برابر 5 است. در نهایت، با مقایسه 2 با بیشینه [5،1]، که حالا می‌دانیم برابر 5 است، به پاسخ مسئله اصلی می‌رسیم. از آنجا که 5 بزرگتر از 2 است، حالا می‌توانیم بگوییم که 5 بیشینه [2،5،1] است.

A Few More Recursive Functions

حال که دیدیم چگونه به صورت بازگشتی فکر کنیم، بیایید چند تابع دیگر را به این روش پیاده‌سازی کنیم. مانند maximum، این توابع در حال حاضر در Haskell وجود دارند، اما ما نسخه خودمان را برای تقویت عضلات بازگشتی در گروه های عضلانی بازگشتی خودمان ایجاد خواهیم کرد. بیایید ورزش کنیم!


replicate 

در ابتدا، ما replicate را پیاده‌سازی خواهیم کرد. به یاد داشته باشید که replicate یک عدد صحیح و یک مقدار را می‌گیرد و یک لیست با چندین تکرار از آن مقدار (به تعدادی که عدد صحیح مشخص می‌کند) برمی‌گرداند. به عنوان مثال، replicate 3 5 یک لیست سه تایی از عدد پنج برمی‌گرداند: [5، 5، 5].

بیایید در مورد موارد پایه فکر کنیم. اگر بخواهیم چیزی را صفر یا کمتر از صفر بار تکرار کنیم، فوراً می‌دانیم چه چیزی را برگردانیم. اگر سعی کنیم چیزی را صفر بار تکرار کنیم، باید یک لیست خالی دریافت کنیم. و ما اعلام می‌کنیم که نتیجه برای اعداد منفی باید همان باشد، زیرا تکرار کردن یک مورد کمتر از صفر بار معنایی ندارد. به طور کلی، یک لیست با n تکرار از x، یک لیست با x به عنوان سر و یک دنباله از x های تکرار شده n-1 بار است. ما کد زیر را دریافت می‌کنیم:

```
replicate' :: Int -> a -> [a]
replicate' n x
| n <= 0
= []
| otherwise = x : replicate' (n-1) x
```

در اینجا از guard استفاده کرده‌ایم به جای الگوها، زیرا ما در حال تست یک شرط بولین هستیم.

take

حالا باید تابع take را پیاده‌سازی کنیم. این تابع یک تعداد مشخصی از المان‌ها را از یک لیست مشخص بازمی‌گرداند. به عنوان مثال، take 3 [5،4،3،2،1] باید لیست [5،4،3] را بازگرداند. اگر صفر یا کمتر از صفر عنصر از یک لیست را بخواهیم بگیریم، باید یک لیست خالی دریافت کنیم و اگر سعی کنیم هر چیزی را از یک لیست خالی بگیریم، باید یک لیست خالی دریافت کنیم. توجه کنید که این دو مورد، دو مورد پایه ما هستند. حالا بیایید تابع را بنویسیم:

```
take' :: (Num i، Ord i) => i -> [a] -> [a]
take' n _
| n <= 0 = []
take' _ []
= []
take' n (x:xs) = x : take' (n-1) xs
```

توجه کنید که در الگوی اول که مشخص می‌کند اگر صفر یا کمتر از صفر عنصر از یک لیست را بخواهیم بگیریم، یک لیست خالی دریافت می‌کنیم، از نماد  _ برای مطابقت با مقدار لیست استفاده می‌کنیم، زیرا در این مورد واقعاً اهمیتی ندارد که چیست. همچنین توجه کنید که از guard استفاده کرده‌ایم، اما بدون بخش otherwise. این به این معنی است که اگر n بیشتر از صفر باشد، مطابقت به الگوی بعدی منتقل می‌شود.
الگوی دوم نشان می‌دهد که اگر سعی کنیم هر تعداد چیزی را از یک لیست خالی بگیریم، یک لیست خالی دریافت می‌کنیم.
الگوی سوم لیست را به سر و دم تقسیم می‌کند. سر را x و دم را xs می‌نامیم. سپس تعیین می‌کنیم که گرفتن n عنصر از یک لیست همان چیزی است که یک لیست با x به عنوان عنصر اول و n-1 عنصر از xs به عنوان عناصر باقیمانده خود را ایجاد می‌کند.


reverse

تابع reverse یک لیست را گرفته و یک لیست با عناصر همان لیست را با ترتیب برعکس برمی‌گرداند. یکبار دیگر، لیست خالی مورد پایه است، زیرا تلاش برای برعکس کردن یک لیست خالی منجر به دریافت لیست خالی می‌شود. باقی بخش تابع چگونه است؟ خوب، اگر ما لیست اصلی را به سر و دم آن تقسیم کنیم، لیست برعکسی که می‌خواهیم برعکس دم است، با سر در انتها قرار دارد:

```
reverse' :: [a] -> [a]
reverse' [] = []
reverse' (x:xs) = reverse' xs ++ [x]
```

repeat

تابع repeat یک عنصر را دریافت می‌کند و یک لیست بی‌نهایت از آن عنصر را تشکیل می‌دهد. پیاده‌سازی بازگشتی تابع repeat واقعاً آسان است:

```
repeat' :: a -> [a]
repeat' x = x:repeat' x
```

فراخوانی repeat 3 به ما یک لیست می‌دهد که با 3 به عنوان سر شروع می‌شود و دارای تعداد بی‌نهایتی 3 به عنوان دم است. بنابراین فراخوانی repeat 3 به 3:repeat 3 تبدیل می‌شود، که به 3:(3:repeat 3) تبدیل می‌شود، که به 3:(3:(3:repeat 3)) و غیره تبدیل می‌شود. repeat 3 هرگز به پایان نخواهد رسید. با این حال، take 5 (repeat 3) یک لیست پنج 3 برای ما ایجاد می‌کند. در واقع، مانند فراخوانی replicate 5 3 است.
این یک مثال خوب از این است که چگونه می‌توانیم از بازگشتی استفاده کنیم که پایانی ندارد تا لیست‌های بی‌نهایت را ایجاد کنیم - فقط باید مطمئن شویم که در طول راه آن‌ها را قطع می‌کنیم.


zip

zip یک تابع دیگر برای کار با لیست‌هاست که در فصل ۱ با آن آشنا شدیم. این تابع دو لیست را گرفته و آن‌ها را با هم زیپ می‌کند. به عنوان مثال، فراخوانی zip [1،2،3] [7،8] به [(1،7)،(2،8)] تبدیل می‌شود (این تابع لیست بلندتر را به طول لیست کوتاه‌تر قرار می‌دهد).
زیپ کردن چیزی با یک لیست خالی فقط یک لیست خالی را بازمی‌گرداند، که ما را به مورد پایه می‌رساند. با این حال، zip دو لیست را به عنوان پارامتر می‌گیرد، بنابراین در واقع دو مورد پایه وجود دارد:

```
zip' :: [a] -> [b] -> [(a,b)]
zip' _ [] = []
zip' [] _ = []
zip' (x:xs) (y:ys) = (x,y):zip' xs ys
```

الگوهای اول و دوم مورد پایه ما هستند: اگر لیست اول یا دوم خالی باشد، یک لیست خالی باز می‌گردانیم. الگوی سوم می‌گوید که زیپ کردن دو لیست با هم، معادل جفت کردن سرهای آن‌هاست، سپس دم‌های زیپ شده آن‌ها را به آن اضافه می‌کنیم.

به عنوان مثال، اگر با [1،2،3] و ['a'،'b'] به zip' فراخوانی کنیم، تابع (1،'a') را به عنوان اولین عنصر نتیجه تشکیل می‌دهد، سپس [2،3] و [b] را با هم زیپ کرده و برای ادامه نتیجه استفاده می‌کند. پس از یک فراخوانی بازگشتی دیگر، تابع سعی می‌کند [3] را با [] زیپ کند، که با یکی از الگوهای مورد پایه مطابقت دارد. نتیجه نهایی به صورت (1،'a'):( (2،'b'):[]) محاسبه می‌شود، که همان [(1،'a')،(2،'b')] است.


elem

بیایید یک تابع دیگر از کتابخانه استاندارد را نیز پیاده‌سازی کنیم: elem. این تابع یک مقدار و یک لیست را گرفته و بررسی می‌کند که آیا مقدار عضو لیست است یا خیر. همانطور که دوباره مشاهده می‌کنیم، لیست خالی یک مورد پایه است - یک لیست خالی هیچ مقداری را شامل نیست، بنابراین قطعاً نمی‌تواند مقداری که به دنبال آن هستیم را داشته باشد. به طور کلی، اگر شانس خوبی داشته باشیم، مقداری که به دنبالش هستیم ممکن است در سر لیست باشد؛ در غیر این صورت، باید بررسی کنیم که آیا در دم لیست است یا نه. کد به شرح زیر است:

```
elem' :: (Eq a) => a -> [a] -> Bool
elem' a [] = False
elem' a (x:xs)
| a == x
= True
| otherwise = a `elem'` xs
```


Quick, Sort!

مسئله مرتب‌سازی یک لیست حاوی عناصری که می‌توانند به ترتیب قرار گیرند (مانند اعداد) به طور طبیعی به یک راه حل بازگشتی منجر می‌شود. رویکردهای متعددی برای مرتب‌سازی بازگشتی لیست‌ها وجود دارد، اما ما به یکی از جالب‌ترین آنها، یعنی quicksort، خواهیم پرداخت. در ابتدا، نحوه عملکرد الگوریتم را بررسی می‌کنیم و سپس آن را در Haskell پیاده‌سازی می‌کنیم.

الگوریتم

الگوریتم quicksort به این صورت کار می‌کند. شما یک لیست دارید که می‌خواهید آن را مرتب کنید، مانند [5،1،9،4،6،7،3]. ابتدا عنصر اول را انتخاب می‌کنید، که 5 است، و تمام عناصر دیگری که کوچکتر یا مساوی 5 هستند را در سمت چپش قرار می‌دهید. سپس عناصری که بزرگتر از 5 هستند را در سمت راستش قرار می‌دهید. اگر این کار را انجام دهید، یک لیستی خواهید داشت که شبیه به این خواهد بود: [1،4،3،5،9،6،7]. در این مثال، 5 به عنوان پیوت انتخاب شده است، زیرا ما تصمیم گرفتیم دیگر عناصر را با آن مقایسه کرده و آن‌ها را به سمت چپ و راستش حرکت دهیم. تنها دلیلی که ما عنصر اول را به عنوان پیوت انتخاب کردیم، آن است که با استفاده از الگوی مطابقت، آسان است. اما واقعاً هر عنصری می‌تواند پیوت باشد.

حالا، ما تمام عناصری که در سمت چپ و راست پیوت هستند را به صورت بازگشتی با فراخوانی همان تابع روی آن‌ها مرتب می‌کنیم. نتیجه نهایی یک لیست کاملاً مرتب شده است!

تصویر بالا نحوه کار کوییک سورت روی مثال ما را نشان می دهد. هنگامی که می خواهیم [5،1،9،4،6،7،3] را مرتب کنیم، تصمیم می گیریم که عنصر اول، پیوت ما باشد. سپس آن را بین [1،4،3] و [9،6،7] قرار می دهیم. پس از آن، [1،4،3] و [9،6،7] را با استفاده از همان رویکرد مرتب می کنیم. برای مرتب کردن [1،4،3]، عنصر اول 1 را به عنوان پیوت انتخاب می کنیم و لیستی از عناصری که کوچکتر یا مساوی 1 هستند، می سازیم. این لیست، به علت اینکه 1 کوچکترین عنصر در [1،4،3] است، لیست خالی، [] است. عناصر بزرگتر از 1 به سمت راست آن می روند، بنابراین این [4،3] است. دوباره، [4،3] به همان روش مرتب می شود. در نهایت، به لیست های خالی تقسیم شده و با هم ترکیب می شوند. الگوریتم سپس به سمت راست 1 باز می گردد که در سمت چپ آن لیست خالی وجود دارد. ناگهان، ما [1،3،4] را داریم که مرتب شده است. این در سمت چپ 5 نگه داشته می شود. هنگامی که عناصر در سمت راست 5 به همان روش مرتب شوند، یک لیست کاملاً مرتب شده خواهیم داشت: [1،3،4،5،6،7،9].


The Code

حال که با الگوریتم quicksort آشنا شدیم، بیایید وارد پیاده‌سازی آن در Haskell شویم:

```
quicksort :: (Ord a) => [a] -> [a]
quicksort [] = []
quicksort (x:xs) =
    let smallerOrEqual = [a | a <- xs, a <= x]
        larger = [a | a <- xs, a > x]
    in quicksort smallerOrEqual ++ [x] ++ quicksort larger
```

امضای تابع ما quicksort :: (Ord a) => [a] -> [a] است، و لیست خالی به عنوان مورد پایه در نظر گرفته شده است، همانطور که در بالا دیدیم.
به یاد دارید که ما تمامی عناصر کمتر یا مساوی با x (pivot) را به چپ آن قرار می‌دهیم. برای بازیابی این عناصر، از طریق ترکیب‌نویسی لیست [a | a <- xs، a <= x] استفاده می‌کنیم. این ترکیب‌نویسی لیست از xs (تمام عناصری که پیوت ما نیستند) استفاده می‌کند و فقط آن‌هایی را که شرط a <= x را برآورده می‌کنند، یعنی آن‌هایی که کمتر یا مساوی با x هستند، نگه می‌دارد. سپس با استفاده از همین روش، لیست عناصر بزرگتر از x را به دست می‌آوریم.
با استفاده از let binding، دو نام مفید برای این دو لیست ایجاد می‌کنیم: smallerOrEqual و larger. در نهایت، با استفاده از اپراتور اتصال لیست (++) و اعمال بازگشتی تابع quicksort، بیان می‌کنیم که می‌خواهیم لیست نهایی خود را از یک لیست smallerOrEqual مرتب شده، پیوت ما و سپس یک لیست larger مرتب شده تشکیل دهیم.
بیایید تابع خود را تست کنیم تا ببینیم آیا به درستی عمل می‌کند:

```
ghci> quicksort [10,2,5,3,1,6,7,4,2,3,4,8,9]
[1,2,2,3,3,4,4,5,6,7,8,9,10]
ghci> quicksort "the quick brown fox jumps over the lazy dog"
"
abcdeeefghhijklmnoooopqrrsttuuvwxyz"
```

همین چیزی است که به دنبالش بودیم!


Thinking Recursively

در این فصل از برنامه‌نویسی، از بازگشتی به طرز چشمگیری استفاده کرده‌ایم و شاید شما هم متوجه الگویی در آن شده باشید. در ابتدا، یک حالت پایه تعریف می‌کنیم: یک راه‌حل ساده و غیر بازگشتی که زمانی که ورودی ساده است، کاربرد دارد. به عنوان مثال، نتیجه مرتب سازی یک لیست خالی، لیست خالی است، زیرا - خب، چه چیز دیگری می‌تواند باشد؟ سپس، مشکل خود را به یک یا بیشتر زیر مسئله تقسیم می‌کنید و با استفاده از تابع مشابه، آن‌ها را به صورت بازگشتی حل می‌کنید. سپس با استفاده از راه‌حل‌های حل شده زیر مسئله، راه‌حل نهایی خود را ساخته و بسازید. به عنوان مثال، در مرتب سازی، لیست خود را به دو لیست، به علاوه یک محور تقسیم کردیم. ما هر یک از این لیست‌ها را به صورت جداگانه با استفاده از تابع مشابه، مرتب سازی کردیم. هنگامی که نتایج را دریافت کردیم، آن‌ها را به یک لیست مرتب بزرگ ترکیب کردیم. بهترین روش برای نزدیک شدن به بازگشتی، شناسایی حالت‌های پایه و فکر کردن درباره اینکه چگونه می‌توانید مشکل خود را به چیزی شبیه، اما کوچک‌تر تقسیم کنید. اگر حالت‌های پایه و زیر مسئله‌ها را به درستی انتخاب کرده باشید، حتی نیازی به فکر کردن درباره جزئیات اینکه همه چیز چگونه اتفاق می‌افتد نیست. می‌توانید فقط به راه حل‌های زیر مسئله‌ها اعتماد کنید، سپس می‌توانید راه‌حل نهایی خود را از این راه‌حل‌های کوچک‌تر ساخته و بسازید.
