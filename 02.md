

یکی از بزرگ‌ترین قدرت‌های `Haskell`، سیستم قدرتمند نوع داده آن است.

در `Haskell`، نوع هر عبارت در زمان کامپایل شناخته می‌شود که منجر به کد ایمن‌تر می‌شود. اگر برنامه‌ای را بنویسید که سعی می‌کند یک نوع `Boolean` را با یک عدد تقسیم کند، کامپایل نمی‌شود. این خوب است زیرا بهتر است این نوع خطاها را در زمان کامپایل گرفت، تا بعداً برنامه شما کرش کند. هر چیزی در `Haskell` یک نوع دارد، بنابراین کامپایلر می‌تواند قبل از کامپایل کردن بسیاری از مسائل در برنامه شما را بررسی کند.

بر خلاف `Java` یا `Haskell` ، `Pascal` دارای استنباط نوع است. اگر عددی بنویسیم، به عنوان مثال، نیازی به این نیست که به `Haskell` بگوییم که این یک عدد است، زیرا می‌تواند به تنهایی این را استنباط کند.

تا اینجا، با نگاهی بسیار سطحی به نوع‌ها، برخی از مبانی `Haskell` را پوشش داده‌ایم، اما فهمیدن سیستم نوع بخش مهمی از یادگیری `Haskell` است.


**تعریف نوع صریح (Explicit Type Declaration)**

می‌توانیم از `GHCi` برای بررسی نوع برخی از عبارات استفاده کنیم. برای این کار از دستور `t:` استفاده می‌کنیم که پس از آن هر عبارت معتبری را دنبال می‌کند و نوع آن را به ما می‌گوید. بیایید امتحانش کنیم:

```
ghci> :t 'a'
'a' :: Char
ghci> :t True
True :: Bool
ghci> :t "HELLO!"
"HELLO!" :: [Char]
ghci> :t (True، 'a')
(True، 'a') :: (Bool، Char)
ghci> :t 4 == 5
4 == 5 :: Bool
```

در اینجا عملگر `::` به عنوان "نوع ... دارد" خوانده می‌شود. نوع های صریح همیشه با حرف اول بزرگ نشان داده می‌شوند. `'a'` نوع `Char` را دارد که به معنای کاراکتر است. `True` یک نوع `Bool` یا یک نوع `Boolean` است. `"!HELLO"` که یک رشته است، نوع خود را به عنوان `[Char]` نشان می‌دهد. پرانتز مربع بیانگر یک لیست است، بنابراین ما آن را به عنوان یک لیست از کاراکترها می‌خوانیم. برخلاف لیست‌ها، هر طول تاپل نوع خود را دارد. بنابراین تاپل `('True, 'a)` نوع `(Bool, Char)` را دارد و `('a', 'b', 'c')` نوع `(Char, Char, Char)` را دارد. `4 == 5` همیشه `False` را برمی‌گرداند، بنابراین نوع آن `Bool` است.

توابع همچنین دارای نوع هستند. وقتی که توابع خود را می‌نویسیم، می‌توانیم تعریف نوع صریحی برای آن‌ها ارائه دهیم. این به طور کلی به عنوان یک شیوه خوب شناخته می‌شود (به جز در مواردی که توابع بسیار کوتاهی را می‌نویسیم). از این پس، برای همه توابعی که ما می‌سازیم، تعریف نوع خواهیم داد.

آیا به آن لیست فشرده‌سازی که در فصل ۱ ساختیم، یاد می‌آورید؟ آن لیست که حروف کوچک رشته را حذف می‌کند؟ اینجا نحوه نوشتن آن با تعریف نوع است:

```
removeNonUppercase :: [Char] -> [Char]
removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]
```

تابع `removeNonUppercase` نوع `[Char] <- [Char]` را دارد که به معنای گرفتن یک رشته به عنوان پارامتر و برگرداندن یک رشته به عنوان نتیجه است. اما چگونه می‌توانیم نوع یک تابع را که چندین پارامتر دارد، مشخص کنیم؟ اینجا یک تابع ساده وجود دارد که سه عدد صحیح را می‌گیرد و آن‌ها را با هم جمع می‌کند:

```
addThree :: Int -> Int -> Int -> Int
addThree x y z = x + y + z
```

پارامترها و نوع بازگشتی با کاراکترهای `<-` جدا شده‌اند و همیشه نوع بازگشتی در انتهای تعریف قرار می‌گیرد. (در فصل ۵، خواهید دید که چرا همه آن‌ها با `<-` جدا شده‌اند و به جای داشتن تفاوت صریح، از این روش استفاده می‌شود.)

اگر می‌خواهید به تابع خود تعریف نوع دهید، اما به چه چیزی نیاز دارید، می‌توانید تابع را بدون تعریف نوع بنویسید و سپس با استفاده از `t:` آن را بررسی کنید. از آنجا که توابع بیانیه هستند، `t:` بر روی آن‌ها به همان روشی که در ابتدای این بخش دیدید، کار می‌کند.


**انواع متداول هسکل (Common Haskell Types)**

بیایید نگاهی به برخی از انواع متداول `Haskell` بیندازیم که برای نمایش اشیاء پایه مانند اعداد، کاراکترها و مقادیر بولین استفاده می‌شوند. اینجا یک نمای کلی وجود دارد:

تایپ `Int` برای عدد صحیح استفاده می‌شود. این برای اعداد صحیح استفاده می‌شود. `7` می‌تواند یک Int باشد، اما `7.2` نمی‌تواند. `Int` محدود است، یعنی دارای یک مقدار حداقل و یک مقدار حداکثر است.

توجه کنید: ما از کامپایلر `GHC` استفاده می‌کنیم، که محدوده `Int` توسط اندازه یک واژه ماشین در کامپیوتر شما تعیین می‌شود. بنابراین، اگر یک `CPU ۶۴` بیتی داشته باشید، احتمالاً کمترین `Int` در سیستم شما `63^2-` و بیشترین آن `63^2` خواهد بود.

تایپ `Integer` همچنین برای ذخیره اعداد صحیح استفاده می‌شود، اما محدود نیست، بنابراین می‌تواند برای نمایش اعداد بسیار بزرگ استفاده شود. (و منظورم واقعاً بزرگ است!) با این حال، `Int` کارآمدتر است. به عنوان مثال، این تابع را در یک پرونده ذخیره کنید و تست کنید:

```
factorial :: Integer -> Integer
factorial n = product [1..n]
```

سپس آن را با استفاده از `l:` به `GHCi` بارگذاری کنید و آن را تست کنید:

```
ghci> factorial 50
30414093201713378043612608166064768844377641568960512000000000000
```

تایپ `Float` یک عدد ممیز شناور واقعی با دقت واحد است. تابع زیر را به پرونده‌ای که در آن کار می‌کرده‌اید، اضافه کنید:

```
circumference :: Float -> Float
circumference r = 2 * pi * r
```

سپس آن را بارگیری و تست کنید:

```
ghci> circumference 4.0
25.132742
```

تایپ `Double` یک عدد ممیز شناور واقعی با دقت دو برابر است. انواع عددی با دقت دو برابر از بیت های دو برابر برای نمایش اعداد استفاده می کنند. بیت های اضافی دقت خود را به قیمت افزایش حافظه افزایش می دهند. تابع زیر را نیز به پرونده خود اضافه کنید:

```
circumference' :: Double -> Double
circumference' r = 2 * pi * r
```

سپس آن را بارگیری و تست کنید. به تفاوت دقت بین `circumference` و `'circumference` توجه ویژه داشته باشید.

```
ghci> circumference' 4.0
25.132741228718345
```

تایپ Bool یک نوع بولین است. فقط می‌تواند دو مقدار `True` و `False` داشته باشد.

تایپ `Char` یک کاراکتر یونیکد را نمایش می‌دهد. با استفاده از نقل قول تکی مشخص می‌شود. یک لیست از کاراکترها یک رشته است.

حتی `Tuple`ها نوع هستند، اما تعریف آن‌ها به طول و نوع مؤلفه‌هایشان بستگی دارد. بنابراین، در نظریه، تعداد نامحدودی از انواع `Tuple` وجود دارد. (در عمل، `Tuple`ها حداکثر می‌توانند `۶۲` عنصر داشته باشند - بسیار بیشتر از آنچه که هرگز نیاز دارید.) توجه کنید که `Tuple` خالی () نیز یک نوع است که فقط یک مقدار () را می‌تواند داشته باشد.


متغیرهای نوع
برای برخی توابع، منطقی است که بتوانند روی انواع مختلف عمل کنند. به عنوان مثال، تابع `head` یک لیست را می‌گیرد و عنصر سری آن لیست را برمی‌گرداند. اصلاً مهم نیست که لیست شامل اعداد، کاراکترها یا حتی لیست‌های دیگری باشد! تابع باید بتواند با لیست‌هایی که شامل هر چیزی هستند کار کند.
فکر می‌کنید نوع تابع `head` چیست؟ با تابع `t:` بررسی کنیم:

```
ghci> :t head
head :: [a] -> a
```

این a چیست؟ به خاطر داشته باشید که نام‌های نوع با حروف بزرگ شروع می‌شوند، بنابراین نمی‌تواند یک نوع باشد. در واقع، این یک نمونه از متغیر نوع است، به این معنی که a می‌تواند از هر نوعی باشد.

متغیرهای نوع به توابع اجازه می‌دهند تا به صورت ایمن از نظر نوع روی مقادیر انواع مختلف عمل کنند. این کار شبیه به جنریک در زبان‌های برنامه‌نویسی دیگر است. با این حال، نسخه `Haskell` قدرتمندتر است، زیرا به ما امکان می‌دهد به راحتی توابع بسیار کلی را بنویسیم.
توابعی که از متغیرهای نوع استفاده می‌کنند، توابع چندروشی نامیده می‌شوند. اعلام نوع `head` می‌گوید که این تابع یک لیست از هر نوعی را می‌گیرد و یک عنصر از آن نوع را برمی‌گرداند.
توجه کنید که با وجود اینکه متغیرهای نوع می‌توانند نام‌هایی با طول بیشتر از یک کاراکتر داشته باشند، معمولاً به آن‌ها نام‌هایی مانند `a`، `b`، `c`، `d` و غیره می‌دهیم.
آیا به تابع `fst` یاد می‌آورید؟ این تابع مورد استفاده برای برگرداندن اولین مورد در یک جفت است. بیایید نوع آن را بررسی کنیم:
```
ghci> :t fst
fst :: (a, b) -> a
```

می‌توانید ببینید که `fst` یک `tuple` را می‌گیرد و یک عنصر از همان نوع اول آن را برمی‌گرداند. به همین دلیل ما می‌توانیم از `fst` در یک جفت استفاده کنیم که شامل مواردی از دو نوع مختلف است. توجه کنید که با وجود اینکه `a` و `b` متغیرهای نوع متفاوتی هستند، ضرورتاً باید نوع‌های مختلف باشند. این فقط به این معنی است که نوع عنصر اول و نوع مقدار برگشتی یکسان خواهد بود.

کلاس‌های نوع 101
کلاس نوع یک رابط است که برخی رفتارها را تعریف می‌کند. اگر یک نوع نمونه‌ای از کلاس نوع باشد، آنگاه پشتیبانی و پیاده‌سازی رفتاری را که کلاس نوع توصیف می‌کند، انجام می‌دهد.
به طور خاص، یک کلاس نوع برخی از توابع را مشخص می‌کند، و زمانی که تصمیم می‌گیریم یک نوع را نمونه‌ای از کلاس نوع کنیم، برای آن نوع مشخص می‌کنیم که آن توابع به چه معناست.
یک کلاس نوع که برابری را تعریف می‌کند، مثال خوبی است. مقدارهای بسیاری از انواع می‌توانند با استفاده از اپراتور `==` برای برابری مقایسه شوند. بیایید نوع این اپراتور را بررسی کنیم:

```
ghci> :t (==)
(==) :: (Eq a) => a -> a -> Bool
```

توجه کنید که اپراتور برابری `(==)` در واقع یک تابع است. همچنین `+`، `*`، `-`، `/` و تقریباً هر اپراتور دیگری نیز تابعی هستند. اگر یک تابع فقط از کاراکترهای ویژه تشکیل شده باشد، به طور پیش فرض به عنوان یک تابع نیمه‌فکری در نظر گرفته می‌شود. اگر می‌خواهیم نوع آن را بررسی کنیم، به یک تابع دیگر منتقل کنیم یا به عنوان یک تابع پیشوندی فراخوانی کنیم، باید آن را در پرانتز قرار دهیم، مانند مثال قبلی.
این مثال چیز جدیدی را نشان می‌دهد: نماد `=>`. هر چیزی قبل از این نماد به عنوان محدودیت کلاس شناخته می‌شود. ما می‌توانیم این تعریف نوع را به این صورت بخوانیم: تابع برابری هر دو مقداری را که از همان نوع هستند می‌گیرد و یک `Bool` برمی‌گرداند. نوع این دو مقدار باید نمونه‌ای از کلاس `Eq` باشد.
کلاس نوع `Eq` یک رابط برای تست برابری فراهم می‌کند. اگر دو مورد از یک نوع خاص برای برابری مقایسه شدند، آنگاه آن نوع می‌تواند یک نمونه از کلاس نوع `Eq` باشد. تمامی انواع استاندارد `Haskell` (به جز انواع ورودی/خروجی و توابع) نمونه‌هایی از `Eq` هستند.

توجه کنید که کلاس‌های نوع با کلاس‌های زبان‌های برنامه‌نویسی شیءگرا متفاوت هستند.

بیایید به برخی از کلاس‌های نوع معمول `Haskell` نگاهی بیندازیم که به ما اجازه می‌دهند تا انواع خود را به راحتی برای برابری و ترتیب، چاپ به عنوان رشته‌ها و غیره مقایسه کنیم.


**کلاس نوع `Eq`**

همانطور که بحث کردیم، `Eq` برای انواعی استفاده می‌شود که از تست برابری پشتیبانی می‌کنند. توابعی که نمونه‌های آن را پیاده‌سازی می‌کنند، `==` و `/=` هستند. این بدان معنی است که اگر یک محدودیت کلاس `Eq` برای یک متغیر نوع در یک تابع وجود داشته باشد، از `==` یا `/=` در جایی در تعریف خود استفاده می‌کند. وقتی یک نوع یک تابع را پیاده‌سازی می‌کند، بدین معنی است که آن تابع را هنگام استفاده با آن نوع خاص تعریف می‌کند. در ادامه چند نمونه از انجام این عملیات بر روی نمونه‌های مختلف `Eq` آمده است:
```
ghci> 5 == 5
True
ghci> 5 /= 5
False
ghci> 'a' == 'a'
True
ghci> "Ho Ho" == "Ho Ho"
True
ghci> 3.432 == 3.432
True
```

**کلاس نوع `Ord`**

ا Ord یک کلاس نوع برای انواعی است که مقادیر آن‌ها قابل قرار دادن در یک ترتیب هستند. به عنوان مثال، به نوع عملگر بزرگتر از `(>)` نگاه کنید:
```
ghci> :t (>)
(>) :: (Ord a) => a -> a -> Bool
```

نوع عملگر بزرگتر از `(>)` شبیه نوع برابری `(==)` است. دو مورد را به عنوان پارامتر می‌گیرد و یک `Bool` برمی‌گرداند که به ما می‌گوید آیا رابطه‌ای بین این دو چیز وجود دارد یا خیر.

تمامی نوع‌هایی که تا به حال بحث کرده‌ایم (به جز توابع) نمونه‌هایی از `Ord` هستند. `Ord` تمام توابع مقایسه استانداردی مانند `>`، `<`، `>=` و `<=` را شامل می‌شود.

تابع `compare` دو مقدار را که نوع آن‌ها نمونه‌ای از `Ord` هستند می‌گیرد و یک `Ordering` برمی‌گرداند. `Ordering` یک نوع است که می‌تواند `GT`، `LT` یا `EQ` باشد و به ترتیب بزرگتر از، کمتر از یا برابر باشد.

```
ghci> "Abrakadabra" < "Zebra"
True
ghci> "Abrakadabra" `compare` "Zebra"
LT
ghci> 5 >= 2
True
ghci> 5 `compare` 3
GT
ghci> 'b' > 'a'
True
```

**کلاس نوع Show**

مقادیری که نوع آن‌ها نمونه‌ای از کلاس نوع `Show` هستند، می‌توانند به عنوان رشته‌ها نمایش داده شوند. تمامی نوع‌هایی که تا به حال بحث کرده‌ایم (به جز توابع) نمونه‌هایی از `Show` هستند. متدی که بیشترین استفاده را از نمونه‌های این کلاس نوع می‌کند، `show` است که مقدار داده شده را به عنوان یک رشته چاپ می‌کند:

```
ghci> show 3
"3"
ghci> show 5.334
"5.334"
ghci> show True
"True"
```

**کلاس نوع `Read`**

می‌توان گفت کلاس نوع `Read` نقطه عکس کلاس نوع `Show` است. دوباره، تمامی نوع‌هایی که تا به حال بحث کرده‌ایم نمونه‌هایی از این کلاس نوع هستند. تابع `read` یک رشته را می‌گیرد و مقداری که نوع آن نمونه‌ای از `Read` است را برمی‌گرداند:

```
ghci> read "True" || False
True
ghci> read "8.2" + 3.8
12.0
ghci> read "5" - 2
3
ghci> read "[1,2,3,4]" ++ [3]
[1,2,3,4,3]
```

تا اینجا همه چیز خوب است. اما اگر سعی کنیم `"4" read` را وارد کنیم چه اتفاقی می‌افتد؟

```
ghci> read "4"
:1:0:
Ambiguous type variable 'a' in the constraint:
'Read a' arising from a use of 'read' at :1:0-7
Probable fix: add a type signature that fixes these type variable(s)
```

در اینجا `GHCi` به ما می‌گوید که نمی‌داند ما درخواست چه چیزی را داریم. توجه کنید که در مورد استفاده‌های قبلی از `read`، ما بعد از آن کاری با نتیجه انجام دادیم که به `GHCi` اجازه داد در خروجی مورد نظرمان را حدس بزند. به عنوان مثال، اگر آن را به عنوان یک بولین استفاده کردیم، می‌دانست که باید یک `Bool` برگرداند. اما حالا می‌داند که ما می‌خواهیم یک نوعی که قسمتی از کلاس نوع `Read` است را برگردانیم، اما نمی‌داند کدام یک. بیایید به امضای نوع تابع `read` نگاه کنیم:

```
ghci> :t read
read :: (Read a) => String -> a
```

توجه: `String` نام دیگری برای `[Char]` است. `String` و `[Char]` قابل استفاده متقابل هستند، اما ما از این به بعد اکثراً از `String` استفاده خواهیم کرد زیرا نوشتن آن آسان‌تر است و قابل خواندن‌تر است.

می‌توانیم ببینیم که تابع `read` یک مقدار را برمی‌گرداند که نوع آن نمونه‌ای از `Read` است، اما اگر از آن نتیجه‌ای را در یک نحوی استفاده کنیم، نمی‌تواند بداند کدام نوع است. برای حل این مشکل، می‌توانیم از آنوتیشن نوع استفاده کنیم.
آنوتیشن نوع یک راه برای به صراحت گفتن به `Haskell` نوع یک عبارت است. این کار را با اضافه کردن :: به انتهای عبارت و سپس مشخص کردن نوع انجام می‌دهیم:

```
ghci> read "5" :: Int
5
ghci> read "5" :: Float
5.0
ghci> (read "5" :: Float) * 4
20.0
ghci> read "[1,2,3,4]" :: [Int]
[1,2,3,4]
ghci> read "(3, 'a')" :: (Int, Char)
(3, 'a')
```

کامپایلر می‌تواند نوع بیشتر بیانیه‌ها را به صورت خودکار پیدا کند. با این حال، گاهی اوقات کامپایلر نمی‌داند که برای یک بیانیه مانند `"5" read` باید یک مقدار از نوع `Int` یا `Float` برگرداند. برای دیدن نوع،`Haskell` باید واقعاً `"5" read` را ارزیابی کند. اما از آنجایی که `Haskell` یک زبان با نوع استاتیک است، باید تمامی نوع‌ها را قبل از کامپایل (یا در مورد `GHCi`، ارزیابی) بداند. بنابراین باید به `Haskell` بگوییم "خب، این بیانیه باید این نوع باشد، در صورتی که نمی‌دانستی!"
می‌توانیم تنها حداقل مقداری از اطلاعاتی که برای پیدا کردن نوع مقداری که read باید برگرداند نیاز است به `Haskell` بدهیم. به عنوان مثال، اگر از `read` استفاده کرده و نتیجه آن را در یک لیست فشرده کنیم، `Haskell` می‌تواند با نگاه به عناصر دیگر لیست بفهمد کدام نوع را می‌خواهیم:

```
ghci> [read "True", False, True, False]
[True, False, True, False]
```

از آنجایی که ما از `"read "True` به عنوان یک عنصر در یک لیست از مقادیر `Bool` استفاده کرده‌ایم، `Haskell` می‌بیند که نوع `"read "True` نیز باید `Bool` باشد.


**کلاس نوع `Enum`**

نمونه‌های `Enum` نوع‌های مرتب شده به صورت پیاپی هستند - مقادیر آنها می‌توانند شمرده شوند. مزیت اصلی کلاس نوع `Enum` این است که می‌توانیم از مقادیر آن در محدوده‌های لیست استفاده کنیم. همچنین، پیش‌نیازها و پس‌نیازهای تعریف شده دارند که می‌توانیم با توابع `succ` و `pred` آنها را بدست آوریم. برخی مثال‌هایی از نوع‌هایی که در این کلاس قرار دارند: `()`، `Bool`، `Char`، `Ordering`، `Int`، `Integer`، `Float` و `Double` هستند.

```
ghci> ['a'..'e']
"abcde"
ghci> [LT .. GT]
[LT,EQ,GT]
ghci> [3 .. 5]
[3,4,5]
ghci> succ 'B'
'C'
```

**کلاس نوع `Bounded`**


نمونه‌های کلاس نوع `Bounded` یک حداقل و یک حداکثر دارند که با استفاده از توابع `minBound` و `maxBound` می‌توان آنها را بررسی کرد:

```
ghci> minBound :: Int
-2147483648
ghci> maxBound :: Char
'\1114111'
ghci> maxBound :: Bool
True
ghci> minBound :: Bool
False
```
>
توابع `minBound` و `maxBound` جالب هستند زیرا نوع خودشان را ندارند و دارای نوع `(Bounded a) => a` هستند. به نوعی، ثابت‌های چندریختی هستند.

توجه کنید که تاپل‌هایی که تمام اجزای آنها نمونه‌های کلاس نوع `Bounded` هستند، همچنین به عنوان نمونه‌های کلاس نوع `Bounded` در نظر گرفته می‌شوند:

```
ghci> maxBound :: (Bool, Int, Char)
(True,2147483647,'\1114111')
```

**کلاس نوع `Num`**

یک کلاس عددی است. نمونه‌های آن می‌توانند مانند اعداد عمل کنند. بیایید نوع یک عدد را بررسی کنیم: 

```
ghci> :t 20 
20 :: (Num t) => t
```
 
به نظر می‌رسد که اعداد صحیح نیز ثابت چندجنسی هستند. آن‌ها می‌توانند مانند هر نوعی که نمونه‌ای از کلاس `Num` است (`Int`, `Integer`, `Float` یا `Double`) عمل کنند: 

```
ghci> 20 :: Int 
20 
ghci> 20 :: Integer 
20 
ghci> 20 :: Float 
20.0 
ghci> 20 :: Double 
20.0
```
 
برای مثال، می‌توانیم نوع عملگر `*` را بررسی کنیم: 

```
ghci> :t (*) 
(*) :: (Num a) => a -> a -> a
```
 
این نشان می‌دهد که `*` دو عدد را می‌پذیرد و یک عدد از همان نوع برمی‌گرداند. به دلیل این محدودیت نوع، `(5 :: Int) * (Integer :: 6)` با خطای نوع مواجه خواهد شد، در حالی که `5 * (6 :: Integer)` به درستی کار می‌کند. `5` می‌تواند به عنوان یک `Integer` یا `Int` عمل کند، اما نه هر دو به طور همزمان. 
برای بودن یک نمونه از کلاس `Num`، یک نوع باید قبلاً در `Show` و `Eq` باشد. 



**کلاس نوع `Floating`**

شامل انواع `Float` و `Double` است که برای ذخیره اعداد اعشاری استفاده می‌شوند. توابعی که مقادیری که نمونه‌های کلاس نوع Floating هستند را می‌پذیرند و بازگشتی از اعداد اعشاری برمی‌گردانند، برای انجام محاسبات معنادار نیاز دارند. برخی از مثال‌ها شامل `sin`، `cos` و `sqrt` هستند.


**کلاس نوع `Integral`**

الف `Integral` یک کلاس عددی دیگر است. در حالی که کلاس `Num` شامل تمام اعداد، از جمله اعداد صحیح واقعی است، کلاس `Integral` فقط شامل اعداد صحیح (کل) است. این کلاس نوع شامل انواع `Int` و `Integer` است.
یکی از توابع خصوصاً مفید برای سر و کار با اعداد، تابع `fromIntegral` است. دارای اعلان نوع زیر است:

```
fromIntegral :: (Num b, Integral a) => a -> b
```

توجه کنید که در امضای نوع تابع `fromIntegral`، چندین محدودیت کلاسی وجود دارد. این کاملاً معتبر است - محدودیت‌های چندکلاسی درون پرانتز با کاما از هم جدا می‌شوند.
از امضای نوع آن، می‌توانیم ببینیم که تابع `fromIntegral` یک عدد صحیح را می‌گیرد و آن را به یک عدد کلی تبدیل می‌کند. این بسیار مفید است زمانی که می‌خواهید انواع کلی و اعداد اعشاری با هم به خوبی کار کنند. به عنوان مثال، تابع `length` دارای این اعلان نوع است:

```
length :: [a] -> Int
```

این بدان معناست که اگر سعی کنیم طول یک لیست را بگیریم و آن را با `3.2` جمع کنیم، خطا دریافت خواهیم کرد (زیرا سعی کردیم یک `Int` را با یک عدد اعشاری جمع کنیم). برای برطرف کردن این مشکل، می‌توانیم از تابع `fromIntegral` استفاده کنیم، به این شکل:

```
ghci> fromIntegral (length [1,2,3,4]) + 3.2
7.2
```

**توضیحات نهایی درباره کلاس‌های نوع**

زیرا یک کلاس نوع یک رابط انتزاعی تعریف می‌کند، یک نوع می‌تواند نمونه‌ای از بسیاری از کلاس‌های نوع باشد و یک کلاس نوع نیز می‌تواند بسیاری از نوع‌ها را به عنوان نمونه در بر داشته باشد. به عنوان مثال، نوع `Char` نمونه‌ای از بسیاری از کلاس‌های نوع است، دو مورد از آن‌ها `Eq` و `Ord` هستند، زیرا ما می‌توانیم بررسی کنیم که دو کاراکتر برابر هستند و همچنین آن‌ها را به ترتیب الفبایی مقایسه کنیم.
گاهی اوقات برای اینکه یک نوع بتواند نمونه‌ای از یک کلاس نوع شود، باید ابتدا نمونه‌ای از یک کلاس نوع دیگر باشد. به عنوان مثال، برای بودن یک نمونه از `Ord`، یک نوع باید ابتدا نمونه‌ای از `Eq` باشد. به عبارت دیگر، بودن نمونه‌ای از `Eq` یک پیشنیاز برای بودن نمونه‌ای از `Ord` است. این منطقی است اگر درباره آن فکر کنیم، زیرا اگر بتوانید دو چیز را برای چیدمان مقایسه کنید، باید همچنین بتوانید بفهمید آیا آن چیزها برابر هستند یا خیر.











