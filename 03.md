در این فصل، به نحوه نوشتن توابع `Haskell` به صورتی خوانا و منطقی با استفاده از دستورات زبان می‌پردازیم. در اینجا به روش‌های سریع برای تجزیه مقادیر، جلوگیری از زنجیره‌های `if else` بزرگ و ذخیره نتایج محاسبات میانی برای استفاده مجدد چند باره اشاره می‌کنیم.


تطبیق الگو برای مشخص کردن الگوهایی استفاده می‌شود که داده باید با آنها مطابقت داشته باشد و بر اساس آن الگوها، داده را تجزیه می‌کند.
هنگام تعریف توابع در `Haskell`، می‌توانید برای الگوهای مختلف، بدنه تابع جداگانه‌ای ایجاد کنید. این باعث می‌شود کد ساده و خوانا باشد. شما می‌توانید بر روی تقریبا هر نوع داده‌ای - اعداد، کاراکترها، لیست‌ها، تاپل‌ها و غیره - الگو برداری کنید. به عنوان مثال، بیایید یک تابع ساده بنویسیم که بررسی کند آیا عددی که به آن می‌دهیم `۷` است یا نه:

```
lucky :: Int -> String
lucky 7 = "LUCKY NUMBER SEVEN!"
lucky x = "Sorry, you're out of luck, pal!"
```

وقتی تابع `lucky` را صدا می‌زنید، الگوها از بالا به پایین بررسی می‌شوند. هرگاه آرگومان ارسال شده با یک الگوی مشخص مطابقت داشته باشد، بدنه تابع مربوطه استفاده خواهد شد. تنها راهی که یک عدد می‌تواند با الگوی اول اینجا مطابقت داشته باشد، این است که آن `۷` باشد. در این صورت، بدنه تابع "LUCKY NUMBER SEVEN!" استفاده می‌شود. اگر عدد `۷` نباشد، به الگوی دوم می‌رود که هر چیزی را مطابقت می‌دهد و آن را به x می‌بندد.

وقتی در الگوی ما از یک نام با حروف کوچک (مانند `x`، `y` یا `myNumber`) به جای یک مقدار واقعی (مثل `۷`) استفاده می‌کنیم، به عنوان یک الگوی پوشش‌دهی عمل می‌کند. این الگو همیشه با مقدار ارائه شده مطابقت خواهد داشت و ما قادر خواهیم بود به آن مقدار با نامی که برای الگو استفاده کرده‌ایم، ارجاع دهیم.

تابع نمونه می‌توانست با استفاده از یک عبارت `if` نیز به راحتی پیاده سازی شود. اما اگر بخواهیم تابعی بنویسیم که یک عدد را به عنوان یک کلمه چاپ کند اگر بین `۱` تا `۵` باشد؛ در غیر این صورت، `"Not between 1 and 5"` را چاپ کند، چه؟ بدون تطبیق الگو، ما نیاز خواهیم داشت به ساختن یک درخت `if/then/else` پیچیده. با این حال، تطبیق الگو این تابع را به راحتی قابل نوشتن می‌کند:

```
sayMe :: Int -> String
sayMe 1 = "One!"
sayMe 2 = "Two!"
sayMe 3 = "Three!"
sayMe 4 = "Four!"
sayMe 5 = "Five!"
sayMe x = "Not between 1 and 5"
```

توجه داشته باشید که اگر الگوی آخر `(sayMe x)` را به بالای تابع منتقل کنیم، تابع همیشه "Not between 1 and 5" را چاپ خواهد کرد، زیرا اعداد فرصتی برای پایین رفتن و بررسی الگوهای دیگر نخواهند داشت.
تابع فاکتوریل را که در فصل قبل اجرا کردیم را به خاطر دارید؟ ما فاکتوریال یک عدد n را به عنوان ضرب `[1..n]` تعریف کردیم. همچنین می‌توانیم یک تابع فاکتوریال را به صورت بازگشتی تعریف کنیم. یک تابع به صورت بازگشتی تعریف می‌شود اگر خود را در داخل تعریف خود فراخوانی کند. تابع فاکتوریال معمولا به این شکل در ریاضیات تعریف می‌شود. ما با اینکه می‌گوییم فاکتوریال ۰ برابر ۱ است شروع می‌کنیم. سپس می‌گوییم که فاکتوریال هر عدد صحیح مثبتی برابر آن عدد ضرب در فاکتوریال پیش‌درآمد خود است. به این صورت است که به زبان `Haskell` ترجمه می‌شود:

```
factorial :: Int -> Int
factorial 0 = 1
factorial n = n * factorial (n - 1)
```

این اولین باری است که ما یک تابع را به صورت بازگشتی تعریف کرده‌ایم. بازگشتی بودن بسیار مهم است و ما در فصل `۴` نگاهی دقیق‌نر به آن خواهیم داشت.
تطبیق الگو همچنین ممکن است شکست خورد. به عنوان مثال، ما می‌توانیم یک تابع را به این شکل تعریف کنیم:

```
charName :: Char -> String
charName 'a' = "Albert"
charName 'b' = "Broseph"
charName 'c' = "Cecil"
```

به نظر می رسد این عملکرد در ابتدا به خوبی کار می کند. با این حال، اگر بخواهیم آن را با ورودی‌ای که انتظارش را نداشت فراخوانی کنیم، با یک خطا مواجه می‌شویم:

```
ghci> charName 'a'
"Albert"
ghci> charName 'b'
"Broseph"
ghci> charName 'h'
"*** Exception: tut.hs:(53,0)-(55,21): Non-exhaustive patterns in function charName
```

این شکایت می‌کند که ما "الگوهای نامکمل" داریم و به درستی اینطور است. در هنگام ساختن الگوها، باید همیشه یک الگوی پوشش‌دهی را در انتها قرار دهیم تا برنامه ما در صورت دریافت ورودی غیرمنتظره، کرش نکند.


**تطبیق الگو با تاپل ها (Pattern Matching with Tuples)**

در الگویابی نیز می‌توان از تاپل‌ها استفاده کرد. فرض کنید می‌خواهیم یک تابع بنویسیم که دو بردار در فضای دوبعدی (به صورت جفت) را دریافت کرده و آن‌ها را با هم جمع کند. (برای جمع دو بردار، ما جزء `x` آن‌ها را به صورت مجزا و جزء `y` آن‌ها را به صورت مجزا جمع می‌کنیم.) اینجاست که اگر الگویابی را نمی‌شناختیم، به صورت زیر عمل می‌کردیم:

```
addVectors :: (Double, Double) -> (Double, Double) -> (Double, Double)
addVectors a b = (fst a + fst b, snd a + snd b)
```

خوب، این کار می‌کند، اما روش بهتری وجود دارد. بیایید تابع را به گونه‌ای تغییر دهیم که از الگویابی استفاده کند:

```
addVectors :: (Double, Double) -> (Double, Double) -> (Double, Double)
addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)
```

این روش خیلی بهتر است. با این کار، واضح می‌شود که پارامترها تاپل هستند و با اختصاص نام به جزء‌های تاپل، خوانایی افزایش می‌یابد. توجه کنید که این الگو در حالت کلی استفاده می‌شود. نوع `addVectors` در هر دو حالت یکسان است، بنابراین ما مطمئن هستیم که دو جفت به عنوان پارامتر دریافت می‌کنیم:

```
ghci> :t addVectors
addVectors :: (Double, Double) -> (Double, Double) -> (Double, Double)
```

تابع `fst` و `snd` برای استخراج جزء‌های جفت‌ها استفاده می‌شوند. اما در مورد سه‌تایی‌ها چه؟ خب، هیچ تابعی برای استخراج قسمت سوم یک سه‌تایی وجود ندارد، اما می‌توانیم خودمان آن را بسازیم:

```
first :: (a, b, c) -> a
first (x, _, _) = x
second :: (a, b, c) -> b
second (_, y, _) = y
third :: (a, b, c) -> c
third (_, _, z) = z
```

کاراکتر _ به همان معنی کاراکتر _ در آرایه های فهرستی استفاده می‌شود. ما واقعاً به آن بخش اهمیتی نمی‌دهیم، بنابراین از _ برای نمایش متغیر عمومی استفاده می‌کنیم.
الگویابی نیز می‌تواند در فهرست‌های فهرستی استفاده شود، به این شکل:

```
ghci> let xs = [(1,3),(4,3),(2,4),(5,3),(5,6),(3,1)]
ghci> [a+b | (a, b) <- xs]
[4,7,6,8,11,4]
```

اگر الگویابی شکست خورد، فهرست فهرستی به عنوان نتیجه ایجاد شده، به مورد بعدی منتقل می‌شود و موردی که شکست خورد، در فهرست نهایی قرار نمی‌گیرد.
فهرست‌های معمولی نیز می‌توانند در الگویابی استفاده شوند. می‌توانید با فهرست خالی [] یا هر الگویی که شامل : و فهرست خالی باشد، الگویابی کنید. (به یاد داشته باشید که `[1،2،3]` فقط شکل شکرین آرایه `1:2:3:[]` است.) الگویی مانند `x:xs` سر راه لیست را به x متصل کرده و بقیه را به `xs` متصل می‌کند. اگر فهرست تنها یک عنصر داشته باشد، `xs` به سادگی فهرست خالی خواهد بود.

توجه کنید که برنامه نویسان `Haskell` اغلب الگوی `x:xs` را استفاده می‌کنند، به خصوص با توابع بازگشتی. با این حال، الگوهایی که شامل کاراکتر : هستند، فقط با فهرست‌هایی با طول یک یا بیشتر مطابقت می‌کنند.
حال که به الگویابی در برابر فهرست‌ها نگاه کردیم، بیایید پیاده سازی خودمان از تابع head را بنویسیم:

```
head' :: [a] -> a
head' [] = error "Can't call head on an empty list, dummy!"
head' (x:_) = x
```
بعد از بارگذاری تابع، می‌توانیم آن را به صورت زیر تست کنیم:

```
ghci> head' [4,5,6]
4
ghci> head' "Hello"
'H'
```

توجه کنید که اگر می‌خواهیم چیزی را به چندین متغیر (حتی اگر یکی از آن‌ها فقط ) بیندازیم، باید آن‌ها را در پرانتز قرار دهیم تا هسکل بتواند به درستی آن‌ها را پارس کند. همچنین توجه کنید که از تابع error استفاده شده است. این تابع یک رشته را به عنوان ورودی می‌گیرد و یک خطای اجرایی با استفاده از آن رشته را ایجاد می‌کند. به عبارتی، برنامه شما را متوقف می‌کند، بنابراین استفاده از این تابع باید به حداقل کاهش یابد. (اما استفاده از `head` بر روی یک لیست خالی معنی ندارد!) به عنوان مثال دیگر، بیایید یک تابع ساده بنویسیم که یک لیست را بگیرد و عناصر آن را به صورت یک کلمه‌ای و نامناسب چاپ کند:

```
tell :: (Show a) => [a] -> String
tell [] = "لیست خالی است"
tell (x:[]) = "لیست یک عنصر دارد: " ++ show x
tell (x:y:[]) = "لیست دو عنصر دارد: " ++ show x ++ " و " ++ show y
tell (x:y:_) = "این لیست طولانی است. اولین دو عنصر آن: " ++ show x ++ " و " ++ show y
```

توجه کنید که (`x:[]`) و (`x:y:[]`) می‌توانند به صورت `[x]` و `[x،y]` بازنویسی شوند. با این حال، نمی‌توانیم `(x:y:_)` را با استفاده از کروشه‌های مربعی بازنویسی کنیم، زیرا با هر لیستی با طول `2` یا بیشتر مطابقت دارد. در ادامه چند مثال از استفاده این تابع آورده شده است:

```
ghci> tell [1] "لیست یک عنصر دارد: 1"
ghci> tell [True,False] "لیست دو عنصر دارد: درست و نادرست"
ghci> tell [1,2,3,4] "این لیست طولانی است. اولین دو عنصر آن: 1 و 2"
ghci> tell [] "لیست خالی است"
```

تابع `tell` ایمن است زیرا می‌تواند با لیست خالی، لیست تک عنصری، لیست دو عنصری و لیست با بیشتر از دو عنصر مطابقت پیدا کند. آن به هر طول لیست‌ها را می‌شناسد، بنابراین همیشه مقدار مفیدی را برمی‌گرداند.

اینجا یک تابع تعریف شده که فقط می‌تواند با لیست‌هایی که دارای سه عضو هستند کار کند. در ادامه مثالی از یک تابع با این خصوصیت آمده است:

```
badAdd :: (Num a) => [a] -> a
badAdd (x:y:z:[]) = x + y + z
```

وقتی یک لیستی را به این تابع بدهیم که انتظارش را ندارد، این اتفاق می‌افتد:

```
ghci> badAdd [100،20]
*** Exception: examples.hs:8:0-25: Non-exhaustive patterns in function badAdd
```

اوه! خوب نیست! اگر این اتفاق در داخل یک برنامه کامپایل شده رخ دهد به جای GHCi، برنامه کرش خواهد کرد.
یک نکته دیگر در مورد الگوبرداری با لیست‌ها وجود دارد: شما نمی‌توانید از اپراتور ++ در الگوهای برداری استفاده کنید. (به خاطر داشته باشید که اپراتور `++` دو لیست را با هم ترکیب می‌کند.) به عنوان مثال، اگر سعی کنید با `(xs ++ ys)` الگو برداری کنید، `Haskell` نمی‌تواند بگوید کدام عنصر در لیست xs و کدام عنصر در لیست ys قرار دارد. اگرچه به نظر می‌رسد منطقی باشد که الگو را با `(xs ++ [x،y،z])`، یا حتی فقط `(xs ++ [x])` تطبیق دهیم، اما به دلیل ماهیت لیست‌ها نمی‌توانید این کار را انجام دهید.


As-patterns

الف `As-patterns` در واقع الگوهایی هستند که به شما اجازه می‌دهند یک آیتم را براساس یک الگو تقسیم کنید، در حالی که همچنان به ارجاع به کل آیتم اصلی دسترسی دارید. برای ایجاد یک as-pattern ، یک الگوی معمولی را با یک نام و یک کاراکتر `@` پیش از آن ایجاد کنید. به عنوان مثال، ما می‌توانیم as-pattern زیر را ایجاد کنیم: xs@ (x: y: ys). این الگو دقیقاً با لیست‌هایی که x: y: ys دارند تطبیق پیدا می‌کند، اما شما می‌توانید با استفاده از xs به راحتی به لیست کلی دسترسی داشته باشید، به جای اینکه هر بار باید x: y: ys را تایپ کنید. در ادامه مثالی از یک تابع ساده با استفاده از as-pattern آمده است:

```
firstLetter :: String -> String
firstLetter "" = "Empty string, whoops!"
firstLetter all@(x:xs) = "The first letter of " ++ all ++ " is " ++ [x]
```

بعد از بارگذاری تابع، می‌توانیم آن را به صورت زیر تست کنیم:

```
ghci> firstLetter "Dracula"
"The first letter of Dracula is D"
```
Guards, Guards!

الگوها را برای بررسی اینکه مقادیری که به توابع ما ارسال می‌شوند به چه شکل ساخته شده‌اند، استفاده می‌کنیم. ما از `guards` استفاده می‌کنیم هنگامی که می‌خواهیم تابع ما بررسی کند که آیا برخی از خصوصیات مقادیری که ارسال شده‌اند درست یا غلط است. این به نظر یک عبارت if شبیه است و بسیار شبیه به آن است. با این حال، guards هنگامی که شما چندین شرط داشته باشید بسیار خوانا هستند و با الگوها خوب کار می‌کنند.
بیایید و یک تابع بنویسیم که از `guards` استفاده می‌کند. این تابع شما را به روش‌های مختلفی بر اساس شاخص توده بدن `(BMI)` شما تنبیه می‌کند. BMI شما با تقسیم وزن شما (به کیلوگرم) در مربع قد شما (به متر) محاسبه می‌شود. اگر BMI شما کمتر از 18.5 باشد، شما زیر وزن هستید. اگر بین 18.5 تا 25 باشد، معمولی هستید. BMI بین 25 تا 30 اضافه‌وزن است و بیش از 30 چاقی است. (توجه داشته باشید که این تابع BMI شما را به طور واقعی محاسبه نمی‌کند؛ فقط به عنوان یک آرگومان آن را می‌گیرد و به شما می‌گوید.) اینجا تابع است:

```
bmiTell :: Double => String
bmiTell bmi
    | bmi <= 18.5 = "شما زیر وزن هستید!"
    | bmi <= 25.0 = "شما معمولی هستید!"
    | bmi <= 30.0 = "شما اضافه وزن دارید!"
    | otherwise = "شما چاق هستید!"
```

یک `guard` با علامت لوله `(|)` نشان داده می‌شود، دنباله‌ی آن یک عبارت منطقی است که در صورت برقراری به بدنه تابعی که در صورت برقراری این عبارت استفاده می‌شود، می‌رسد. اگر عبارت منطقی برقرار نباشد، تابع به guard بعدی می‌رود و این فرآیند تکرار می‌شود. `Guards` باید حداقل با یک فاصله برجسته شوند. (من از چهار فاصله برای برجسته کردن آن‌ها استفاده می‌کنم تا کد قابل خواندن تر باشد.)
به عنوان مثال، اگر این تابع را با یک BMI برابر با 24.3 فراخوانی کنیم، ابتدا بررسی می‌کند که آیا آن کمتر یا مساوی با 18.5 است. چون نیست، به guard بعدی می‌رود. بررسی با guard دوم انجام می‌شود و به دلیل اینکه 24.3 کوچکتر از 25.0 است، رشته دوم برگشت داده می‌شود.
`Guards` بسیار به یک درخت `if/else` در زبان‌های امپراتوری شبیه هستند، با این حال قابل خواندن تر هستند. در حالی که درخت `if/els`e بزرگ معمولاً نوعی غلط است، گاهی اوقات یک مسئله به گونه‌ای تعریف می‌شود که نمی‌توانید به دور از آن‌ها بگذرید. Guards در این موارد جایگزین بسیار خوبی هستند.
بسیاری از مواقع، آخرین `guard` در یک تابع `otherwise` است که همه چیز را گرفتار می‌کند. اگر همه guards در یک تابع بررسی شده و ما guard catch-all otherwise را فراهم نکرده‌ایم، ارزیابی به الگوی بعدی می‌رود. (این نحوه‌ی کار کردن الگوها و guards با هم خوب است.) اگر هیچ guards یا الگوی مناسبی پیدا نشود، یک خطا پرتاب می‌شود.
بطور مشابه، ما می‌توانیم `guards` را با توابعی که چندین پارامتر دارند، استفاده کنیم. بیایید `bmiTell` را طوری تغییر دهیم که وزن و قد را بگیرد و BMI را برای ما محاسبه کند:

```
bmiTell :: Double -> Double -> String
bmiTell weight height
    | weight / height ^ 2 <= 18.5 = "You're underweight, you emo, you!"
    | weight / height ^ 2 <= 25.0 = "You're supposedly normal. Pffft, I bet you're ugly!"
    | weight / height ^ 2 <= 30.0 = "You're fat! Lose some weight, fatty!"
    | otherwise = "You're a whale, congratulations!"
```
حالا بیایید ببینیم آیا من چاق هستم:

```
ghci> bmiTell 85 1.90
"You're supposedly normal. Pffft, I bet you're ugly!"
```

آفرین! من چاق نیستم! اما `Haskell` تنبیه کرد که زشت هستم. هرچیزی که باشد!
توجه
یک اشتباه معمول مبتدیان، قرار دادن علامت مساوی (`=)` پس از نام تابع و پارامترها، قبل از اولین `guard` است. این باعث ایجاد خطای نحوی می‌شود.
به عنوان یک مثال ساده دیگر، بیایید تابع max خودمان را پیاده کنیم تا دو مورد را مقایسه کنیم و بزرگترین آن‌ها را برگردانیم:

```
max' :: (Ord a) => a -> a -> a
max' a b
| a <= b = b
| otherwise = a
```

همچنین می‌توانیم تابع `compare` خودمان را با استفاده از `guards` پیاده کنیم:

```
myCompare :: (Ord a) => a -> a -> Ordering
a `myCompare` b
| a == b = EQ
| a <= b = LT
| otherwise = GT
ghci> 3 `myCompare` 2
GT
```

توجه: نه تنها می‌توانیم از علامت `backticks` برای فراخوانی توابع به صورت `infix` استفاده کنیم، بلکه می‌توانیم از آن‌ها برای تعریف توابع استفاده کنیم. گاهی این باعث می‌شود که کد قابل خواندن‌تر باشد.

Where?!

در برنامه‌نویسی، معمولاً می‌خواهیم از محاسبه مقدار یکسان بارها جلوگیری کنیم. بهتر است فقط یک بار مقداری را محاسبه کنیم و آن را ذخیره کنیم. در زبان‌های برنامه‌نویسی دستوری، به حل این مشکل با ذخیره نتیجه محاسبات در یک متغیر پرداخته می‌شود. در این بخش، شما یاد خواهید گرفت که از کلمه کلیدی `where` در `Haskell` برای ذخیره نتایج محاسبات واسطه‌ای استفاده کنید که قابلیت‌های مشابهی را فراهم می‌کند.

در بخش قبل، یک تابع محاسبه `BMI` را به صورت زیر تعریف کردیم:

```
bmiTell :: Double -> Double -> String
bmiTell weight height
    | weight / height ^ 2 <= 18.5 = "You're underweight, you emo, you!"
    | weight / height ^ 2 <= 25.0 = "You're supposedly normal. Pffft, I bet you're ugly!"
    | weight / height ^ 2 <= 30.0 = "You're fat! Lose some weight, fatty!"
    | otherwise = "You're a whale, congratulations!"
```

در این کد، محاسبه `BMI` را سه بار تکرار کرده‌ایم. می‌توانیم با استفاده از کلمه کلیدی where، این محاسبه را یک بار انجام داده و نتیجه را در یک متغیر ذخیره کنیم و سپس از آن متغیر به جای محاسبه `BMI` استفاده کنیم، به صورت زیر:

```
bmiTell :: Double -> Double -> String
bmiTell weight height
    | bmi <= 18.5 = "You're underweight, you emo, you!"
    | bmi <= 25.0 = "You're supposedly normal. Pffft, I bet you're ugly!"
    | bmi <= 30.0 = "You're fat! Lose some weight, fatty!"
    | otherwise = "You're a whale, congratulations!"
    where bmi = weight / height ^ 2
```

در اینجا، کلمه کلیدی `where` را پس از `guards` قرار داده‌ایم و سپس از آن برای تعریف یک یا چند متغیر یا تابع استفاده می‌کنیم. این نام‌ها در تمام `guards` قابل مشاهده هستند. اگر تصمیم بگیریم که می‌خواهیم `BMI` را کمی متفاوت محاسبه کنیم، تنها کافیست یکبار آن را تغییر دهیم. این تکنیک همچنین خوانایی را با اختصاص نام به چیزها بهبود می‌بخشد و حتی می‌تواند برنامه‌های ما را سریع‌تر کند، زیرا مقادیر ما فقط یک بار محاسبه می‌شوند.

اگر بخواهیم، می‌توانیم حتی یکم اغراق کنیم و تابع خود را به این شکل بنویسیم:

```
bmiTell :: Double -> Double -> String
bmiTell weight height
    | bmi <= skinny = "You're underweight, you emo, you!"
    | bmi <= normal = "You're supposedly normal. Pffft, I bet you're ugly!"
    | bmi <= fat = "You're fat! Lose some weight, fatty!"
    | otherwise = "You're a whale, congratulations!"
    where bmi = weight / height ^ 2
        skinny = 18.5
        normal = 25.0
        fat = 30.0
```

توجه کنید که همه نام متغیرها در یک ستون تراز شده‌اند. اگر آنها را به این شکل تراز نکنید، Haskell گیج می‌شود و نمی‌داند که آنها همگی بخشی از یک بلوک هستند.


محدوده Where

متغیرهایی که در بخش `where` یک تابع تعریف می‌کنیم، فقط در آن تابع قابل مشاهده هستند، بنابراین نیازی به نگرانی از آنها برای تلویح نام فضای نام دیگر توابع نداریم. اگر می‌خواهیم یک متغیر را به این شکل در چندین تابع مختلف استفاده کنیم، باید آن را به صورت جهانی تعریف کنیم.

همچنین، اتصال‌های where در بدنه توابع الگوی مختلف به اشتراک گذاشته نمی‌شوند. به عنوان مثال، فرض کنید می‌خواهیم یک تابع بنویسیم که با دریافت یک نام، به شخص با احترام آن نام را تحیت کند و در صورت نشناختن آن نام، به شخص با نام نامطلوب تحیت نکند. می‌توانیم آن را به این شکل تعریف کنیم:

```
greet :: String -> String
greet "Juan" = niceGreeting ++ " Juan!"
greet "Fernando" = niceGreeting ++ " Fernando!"
greet name = badGreeting ++ " " ++ name
where niceGreeting = "Hello! So very nice to see you,"
      badGreeting = "Oh! Pfft. It's you."
```

این تابع به صورت نوشته شده کار نمی‌کند. به دلیل اینکه اتصال‌های `where` در بدنه توابع الگوی مختلف به اشتراک گذاشته نمی‌شوند، فقط بدنه آخرین تابع اتصالات تعریف شده توسط `where` را می‌بیند. برای اینکه این تابع به درستی کار کند، باید `badGreeting` و `niceGreeting` به صورت جهانی تعریف شوند، به این شکل:

```
badGreeting :: String
badGreeting = "Oh! Pfft. It's you."
niceGreeting :: String
niceGreeting = "Hello! So very nice to see you,"
greet :: String -> String
greet "Juan" = niceGreeting ++ " Juan!"
greet "Fernando" = niceGreeting ++ " Fernando!"
greet name = badGreeting ++ " " ++ name
```

همچنین می‌توانید از اتصالات where برای الگوی بندی استفاده کنید. می‌توانستیم بخش `where` تابع `BMI` را به این شکل بنویسیم:

```
...
where bmi = weight / height ^ 2
      (skinny, normal, fat) = (18.5, 25.0, 30.0)
```

به عنوان مثالی از این تکنیک، بیایید یک تابع بنویسیم که نام و نام خانوادگی را دریافت کرده و حروف اول آنها را برگرداند:

```
initials :: String -> String -> String
initials firstname lastname = [f] ++ ". " ++ [l] ++ "."
where   (f:_) = firstname
        (l:_) = lastname

```


می‌توانستیم این الگوی بندی را مستقیماً در پارامترهای تابع انجام دهیم (که کوتاه‌تر و خواناتر بود)، اما این مثال نشان می‌دهد که می‌توان آن را در اتصالات `where` نیز انجام داد.


توابع در بلوک‌های where

همانطور که در بلوک‌های `where` ثابت تعریف کرده‌ایم، می‌توانیم توابع را نیز تعریف کنیم. با ادامه تم محیط برنامه‌نویسی سالم، بیایید یک تابع بنویسیم که لیستی از جفت وزن/قد را دریافت کرده و لیستی از `BMI` ها را برمی‌گرداند:

```
calcBmis :: [(Double, Double)] -> [Double]
calcBmis xs = [bmi w h | (w, h) <- xs]
where bmi weight height = weight / height ^ 2
```

و همین است! دلیلی که در این مثال نیاز به معرفی bmi به عنوان یک تابع داشتیم، این است که نمی‌توانیم فقط یک BMI را از پارامترهای تابع محاسبه کنیم. باید لیستی که به تابع پاس داده شده است را بررسی کنیم و برای هر جفت، یک BMI متفاوت وجود دارد.


let It Be

عبارت let بسیار شبیه به اتصالات `where` است. `where` به شما امکان می‌دهد تا در انتهای یک تابع به متغیرها متصل شوید و این متغیرها در کل تابع قابل مشاهده هستند، از جمله همه محافظ‌های آن. از طرف دیگر، عبارت let به شما اجازه می‌دهد تا به متغیرها در هر جایی متصل شوید و خودشان هم یک عبارت هستند. با این حال، آنها بسیار محلی هستند و بین محافظ‌ها پخش نمی‌شوند. همانطور که در هر ساختار `Haskell` استفاده می‌شود تا مقادیر را به نام‌ها متصل کند، عبارت `let` هم می‌تواند در الگوی بندی استفاده شود.

حالا بیایید عملکرد `let` را ببینیم. تابع زیر مساحت سطح استوانه را براساس ارتفاع و شعاع آن بازمی‌گرداند:

```
cylinder :: Double -> Double -> Double
cylinder r h =
let sideArea = 2 * pi * r * h
topArea = pi * r ^ 2
in sideArea + 2 * topArea
```

عبارت `let` به صورت `let  in`  نوشته می‌شود. متغیرهایی که با `let` تعریف می‌کنید، در کل عبارت `let` قابل مشاهده هستند.

بله، می‌توانستیم این را با یک اتصال `where` هم تعریف کنیم. پس تفاوت اصلی بین دو روش چیست؟ در ابتدا، به نظر می‌رسد تنها تفاوت این است که `let` ابتدا متغیرها را و سپس عبارت را قرار می‌دهد، درحالی که در `where` برعکس است.

در واقع، تفاوت اصلی بین دو روش این است که عبارت `let ... in` یک عبارت است، در حالی که اتصالات where نیستند. اگر چیزی یک عبارت باشد، یعنی یک مقدار دارد. `"boo!"` یک عبارت است، همچنین 3 + 5 و head [1،2،3] نیز عبارت هستند. این بدان معناست که شما می‌توانید عبارت `let` را تقریباً در هرجای کد خود استفاده کنید، مانند این:

```
ghci> 4 * (let a = 9 in a + 1) + 2
42
```

در ادامه چند روش مفید دیگر برای استفاده از عبارت let آمده است:

آنها می‌توانند برای معرفی توابع در یک محدوده محلی استفاده شوند:

```
ghci> [let square x = x * x in (square 5, square 3, square 2)]
[(25,9,4)]
```

آنها می‌توانند با فاصله‌های نیم‌فاصله جدا شوند که وقتی می‌خواهید چندین متغیر را در خطوط متفاوت به صورت خطی متصل کنید، مفید است:

```
ghci> (let a = 100; b = 200; c = 300 in a*b*c, let foo="Hey "; bar = "there!" in foo ++ bar)
(6000000,"Hey there!")
```

تطبیق الگو با عبارت `let` می‌تواند برای تفکیک سریع یک دسته از اجزاء به نام‌ها بسیار مفید باشد. به این صورت:

```
ghci> (let (a, b, c) = (1, 2, 3) in a+b+c) * 100
600
```

در اینجا، ما از یک عبارت let با یک تطبیق الگو برای تفکیک سه‌تایی (1،2،3) استفاده کرده‌ایم. ما اولین اجزای آن را a، دومین اجزای آن را b و سومین اجزای آن را c نامیده‌ایم. قسمت `in a+b+c` بیانگر این است که کل عبارت `let` مقدار `a+b+c` را خواهد داشت. در نهایت، ما آن مقدار را در 100 ضرب می‌کنیم.


شما می‌توانید عبارت let را در داخل فهرستی از فهرست‌ها استفاده کنید. در زیر به این مورد نگاهی می‌اندازیم.

اگر عبارت let به این حد خوب است، چرا همیشه استفاده نمی‌شود؟ خب، از آنجایی که عبارت let یک عبارت است و در محدوده محلی خود نسبتاً محدود است، نمی‌تواند در محافظ‌ها استفاده شود. همچنین، برخی افراد به اتصالات `where` علاقه دارند زیرا متغیرهایشان بعد از تابعی که در آن استفاده می‌شوند، تعریف می‌شوند، نه قبل از آن. این امر باعث می‌شود بدنه تابع به نام و تعریف نوع آن نزدیک‌تر شود و باعث کد قابل خواندن‌تری می‌شود.


let in List Comprehensions

در اینجا، ما مثال قبلی خود را برای محاسبه لیست‌های جفت وزن/قد، با استفاده از یک عبارت let در داخل یک فهرست تفسیری مجدداً می‌نویسیم، به جای تعریف یک تابع کمکی با `where`:

```
calcBmis :: [(Double, Double)] -> [Double]
calcBmis xs = [bmi | (w, h) <- xs, let bmi = w / h ^ 2]
```

هر بار که فهرست تفسیری یک جفت از لیست اصلی را گرفته و اجزای آن را به w و h متصل می‌کند، عبارت let w / h ^ 2 را به نام bmi متصل می‌کند. سپس ما فقط bmi را به عنوان خروجی فهرست تفسیری ارائه می‌دهیم.
ما یک let را در داخل یک فهرست تفسیری به همان شکلی که از یک پیش‌شرط استفاده می‌کنیم، اضافه می‌کنیم، با این تفاوت که به جای فیلتر کردن لیست، فقط مقادیر را به نام‌ها متصل می‌کند. نام‌های تعریف شده در این let قابل مشاهده در خروجی (قسمت قبل از |) و همه چیز در فهرست تفسیری که پس از let می‌آید هستند. بنابراین، با استفاده از این تکنیک، می‌توانیم تابع خود را فقط با بازگشت BMI افراد چاق برگردانیم، مانند این:

```
calcBmis :: [(Double, Double)] -> [Double]
calcBmis xs = [bmi | (w, h) <- xs, let bmi = w / h ^ 2, bmi > 25.0]
```

قسمت `(w، h) <- xs` از فهرست تفسیری، مولد نامیده می‌شود. ما نمی‌توانیم به متغیر `bmi` در مولد ارجاع دهیم، زیرا آن قبل از متصل کردن `let` تعریف شده است.

let in GHCi

قسمت in از پیوست‌کردن همچنین می‌تواند حذف شود هنگامی که توابع و ثابت‌ها را مستقیماً در GHCi تعریف می‌کنیم. اگر این کار را انجام دهیم، آنگاه نام‌ها در طول جلسه تعاملی به صورت قابل مشاهده خواهند بود:

```
ghci> let zoot x y z = x * y + z
ghci> zoot 3 9 2
29
ghci> let boot x y z = x * y + z in boot 3 4 2
14
ghci> boot
:1:0: Not in scope: `boot'
```

زیرا در خط اول `in` را حذف کرده‌ایم، `GHCi` می‌داند که در آن خط از `zoot` استفاده نمی‌کنیم، بنابراین آن را برای بقیه جلسه به یاد می‌آورد. با این حال، در عبارت `let` دوم، ما قسمت `in` را گنجانده و سپس بلافاصله با برخی پارامتر‌ها `boot` را فراخوانی کردیم. یک عبارت let که قسمت `in` را حذف نمی‌کند، به تنهایی یک عبارت است و مقداری را نشان می‌دهد، بنابراین `GHCi` فقط آن مقدار را چاپ می‌کند.


case Expressions

عبارت `case` به شما اجازه می‌دهد که برای مقادیر خاصی از یک متغیر خاص، بلوک‌هایی از کد را اجرا کنید. در اصل، این یک روش برای استفاده از الگوگذاری تقریباً در هر جای کد شماست. بسیاری از زبان‌ها (مانند C، C ++ و Java) دارای نوعی از عبارت `case` هستند، بنابراین شما ممکن است با این مفهوم آشنایی داشته باشید.

هسکل این مفهوم را بهتر و پیشرفته‌تر از آن می‌کند. همانطور که از نامش پیداست، عبارت `case` یک عبارت است، مانند عبارت `if else` و عبارت `let`. نه تنها می‌توانیم بر اساس حالت‌های ممکن مقدار یک متغیر، عبارت‌های ریاضی را ارزیابی کنیم، بلکه می‌توانیم الگوگذاری نیز انجام دهیم. این بسیار شبیه به انجام الگوگذاری بر روی پارامترها در تعریف توابع است، جایی که شما یک مقدار را می‌گیرید، الگوگذاری می‌کنید و بر اساس آن مقدار، بخش‌هایی از کد را ارزیابی می‌کنید. در واقع، این نوع الگوگذاری تنها یک شکر سینتکتیک برای عبارت `case` است. به عنوان مثال، دو قطعه کد زیر کارهای یکسانی را انجام می‌دهند و قابل تعویض هستند:

```
head' :: [a] -> a
head' [] = error "No head for empty lists!"
head' (x:_) = x
```

```
head' :: [a] -> a
head' xs = case xs of [] -> error "No head for empty lists!"
            (x:_) -> x
```

در ادامه، نحو عبارت `case` را مشاهده می‌کنید:

```
case expression of pattern -> result
                   pattern -> result
                   pattern -> result
...
```

این بسیار ساده است. اولین الگویی که با عبارت منطبق می‌شود، استفاده می‌شود. اگر به کل عبارت case برسد و الگوی مناسبی پیدا نشود، یک خطای اجرایی اتفاق می‌افتد.
الگوگذاری بر روی پارامترهای تابع تنها در تعریف توابع امکان پذیر است، اما عبارت case در هر جایی قابل استفاده است. به عنوان مثال، می‌توانید از آنها برای الگوگذاری در وسط یک عبارت استفاده کنید، مانند این:

```
describeList :: [a] -> String
describeList ls = "The list is " ++ case ls of [] -> "empty."
[x] -> "a singleton list."
xs -> "a longer list."
```

در اینجا، عبارت case به این صورت کار می‌کند: ابتدا ls با الگوی یک لیست خالی مقایسه می‌شود. اگر ls خالی باشد، کل عبارت case به مقدار `"empty"` تبدیل می‌شود. اگر ls یک لیست خالی نباشد، سپس با الگوی یک لیست با یک عضو مقایسه می‌شود. اگر الگوی مطابقت داشته باشد، عبارت `case` به مقدار "a singleton list" تبدیل می‌شود. اگر هیچ یک از این دو الگو مطابقت نداشته باشند، سپس الگوی کلی xs اعمال می‌شود. در نهایت، نتیجه عبارت case با رشته `"The list is"` ادغام می‌شود. هر عبارت case یک مقدار را نمایش می‌دهد. به همین دلیل، ما می‌توانیم بین رشته `"The list is"` و عبارت `case` خود از `++` استفاده کنیم.
از آنجایی که الگوگذاری در تعریف توابع مشابه استفاده از عبارت case است، ما همچنین می‌توانیم تابع describeList را به این شکل تعریف کنیم:

```
describeList :: [a] -> String
describeList ls = "The list is " ++ what ls
where what [] = "empty."
what [x] = "a singleton list."
what xs = "a longer list."
```

این تابع همانند تابع مثال قبلی عمل می‌کند، با این حال از یک ساختار نحوی متفاوت برای تعریف آن استفاده کرده‌ایم. تابع `what` با ls فراخوانی می‌شود و سپس عمل الگوگذاری معمول رخ می‌دهد. پس از بازگشت این تابع با یک رشته، با `"The list is"` ادغام می‌شود.




