`HIGHER-ORDER FUNCTIONS`


در زبان هسکل، توابع می‌توانند توابع را به عنوان پارامترها بپذیرند و همچنین توابع را به عنوان مقدار بازگشتی بازگردانند. تابعی که هر یک از این کارها را انجام می‌دهد، تابع بالاترین سفارش نامیده می‌شود. توابع بالاترین سفارش روشی بسیار قدرتمند برای حل مشکلات و فکر کردن درباره برنامه‌ها هستند و وقتی از یک زبان برنامه‌نویسی تابعی مانند هسکل استفاده می‌کنید، ضروری هستند.


`Curried Functions`

هر تابع در هسکل به طور رسمی فقط یک پارامتر را می‌پذیرد. اما ما تعدادی تابع را تعریف و استفاده کرده‌ایم که بیش از یک پارامتر را می‌پذیرند - این چگونه ممکن است؟ خب، این یک حرفه ای است! تمام توابعی که تا به حال با چندین پارامتر مواجه شده‌ایم، توابع کری شده هستند. تابع کری شده، تابعی است که به جای پذیرفتن چندین پارامتر، همیشه دقیقاً یک پارامتر را می‌پذیرد.

سپس هنگامی که با آن پارامتر فراخوانی می‌شود، یک تابع بازگشت داده می‌شود که پارامتر بعدی را می‌پذیرد و به همین ترتیب ادامه می‌یابد.
این بهتر با یک مثال توضیح داده می‌شود. بیایید به دوست خوبمان تابع max نگاه کنیم. به نظر می‌رسد که دو پارامتر را می‌پذیرد و بزرگترین آن‌ها را برمی‌گرداند. به عنوان مثال، عبارت max 4 5 را در نظر بگیرید. ما تابع max را با دو پارامتر 4 و 5 فراخوانی می‌کنیم. ابتدا، max به مقدار 4 اعمال می‌شود. هنگامی که max را به 4 اعمال می‌کنیم، مقداری که برگردانده می‌شود، در واقع یک تابع دیگر است که سپس به مقدار 5 اعمال می‌شود. عمل اعمال این تابع به 5، در نهایت یک مقدار عددی برمی‌گرداند. به عنوان یک پیامد، دو فراخوانی زیر معادل هستند:

```
ghci> max 4 5
5
ghci> (max 4) 5
5
```

برای درک اینکه این چگونه کار می‌کند، بیایید نوع تابع max را بررسی کنیم.

```
ghci> :t max
max :: (Ord a) => a -> a -> a
```

این نیز می‌تواند به شکل زیر نوشته شود:

```
max :: (Ord a) => a -> (a -> a)
```

هرگاه یک امضای نوع دارای پیکان -> باشد، به این معنی است که تابعی است که هر چیزی که در سمت چپ پیکان قرار دارد را می‌پذیرد و یک مقدار با نوعی که در سمت راست پیکان نشان داده شده است، برمی‌گرداند. وقتی مانند a -> (a -> a) داریم، با یک تابع سروکار داریم که یک مقدار با نوع a را می‌پذیرد و یک تابع بازگشتی را برمی‌گرداند که نیز یک مقدار با نوع a را می‌پذیرد و یک مقدار با نوع a را برمی‌گرداند.


پس چگونه این برای ما سودمند است؟ به طور ساده، اگر تابعی را با تعدادی پارامتر کمتر از حد نیاز فراخوانی کنیم، تابعی که جزئیات آن را فراخوانی کرده‌ایم، به عنوان یک تابع جزئیاپذیر برمی‌گردد که تعدادی پارامتر بیشتر برای آن باقی می‌ماند. به عنوان مثال، هنگامی که max 4 را انجام دادیم، یک تابع بازگشتی را که یک پارامتر می‌پذیرد برگرداندیم. استفاده از جزئیاپذیری (فراخوانی تابع با تعداد پارامتر کمتر از حد نیاز) راهی زیبا برای ایجاد توابع در حال اجرا است، بنابراین می‌توانیم آن‌ها را به توابع دیگر منتقل کنیم. به این تابع ساده نگاه کنید:

```
multThree :: Int -> Int -> Int -> Int
multThree x y z = x * y * z
```

واقعا چه اتفاقی می‌افتد هنگامی که multThree 3 5 9 را فراخوانی می‌کنیم، یا ((multThree 3) 5) 9؟
ابتدا، multThree به مقدار 3 اعمال می‌شود، زیرا آن‌ها توسط یک فاصله از یکدیگر جدا شده‌اند. این کار تابعی را ایجاد می‌کند که یک پارامتر را می‌پذیرد و یک تابع بازگشتی را برمی‌گرداند. سپس آن تابع برای 5 اعمال می‌شود، که یک تابع را ایجاد می‌کند که یک پارامتر را می‌پذیرد، 3 و 5 را با یکدیگر ضرب کرده، سپس آن را با پارامتر ضرب می‌کند. سپس این تابع برای 9 اعمال می‌شود و نتیجه یک عدد 135 است.
می‌توانید تصور کنید که توابع به عنوان کارخانه‌های کوچکی هستند که برخی مواد را می‌گیرند و چیزی را تولید می‌کنند. با استفاده از این تشبیه، ما کارخانه multThree خود را با شماره 3 تغذیه می‌کنیم، اما به جای تولید یک عدد، یک کارخانه کوچک‌تر تولید می‌کند. این کارخانه شماره 5 را دریافت می‌کند و همچنین یک کارخانه دیگر تولید می‌کند. کارخانه سوم شماره 9 را دریافت می‌کند، سپس عدد 135 را تولید می‌کند.
به یاد داشته باشید که نوع این تابع همچنین به شکل زیر قابل نوشتن است:

```
multThree :: Int -> (Int -> (Int -> Int))
```

نوع (یا متغیر نوع) قبل از -> نوع مقادیری است که تابع دریافت می‌کند و نوع پس از آن نوع مقادیری است که تابع برمی‌گرداند. بنابراین تابع ما یک مقدار با نوع Int را دریافت کرده و یک تابع با نوع (Int -> (Int -> Int را برمی‌گرداند. به طور مشابه، این تابع یک مقدار با نوع Int را دریافت می‌کند و یک تابع با نوع Int -> Int را برمی‌گرداند. و در نهایت، این تابع فقط یک مقدار با نوع Int را دریافت کرده و یک مقدار دیگر با نوع Int را برمی‌گرداند.
بیایید به مثالی از این که چگونه با فراخوانی یک تابع با تعداد پارامترهای کمتر از حد، می‌توانیم یک تابع جدید ایجاد کنیم، نگاه کنیم:

```
ghci> let multTwoWithNine = multThree 9
ghci> multTwoWithNine 2 3
54
```

در این مثال، عبارت multThree 9 به یک تابع منجر می‌شود که دو پارامتر را می‌پذیرد. ما آن تابع را multTwoWithNine نامگذاری می‌کنیم، زیرا multThree 9 یک تابع است که دو پارامتر را می‌پذیرد. اگر هر دو پارامتر در دسترس باشند، آن‌ها را با یکدیگر ضرب کرده و سپس آن را در 9 ضرب می‌کند، زیرا ما تابع multTwoWithNine را با اعمال multThree بر روی 9 دریافت کرده‌ایم.
اگر بخواهیم یک تابع ایجاد کنیم که یک عدد صحیح (Int) را دریافت کرده و آن را با 100 مقایسه کند چه می‌توانیم انجام دهیم؟ ما می‌توانیم به این صورت عمل کنیم:

```
compareWithHundred :: Int -> Ordering
compareWithHundred x = compare 100 x
```

به عنوان مثال، بیایید با شماره 99 تابع را فراخوانی کنیم:

```
ghci> compareWithHundred 99
GT
```

100 بزرگتر از 99 است، بنابراین تابع GT یا بزرگتر از را برمی‌گرداند.
حالا بیایید درباره‌ی آنچه که compare 100 برمی‌گرداند، فکر کنیم: یک تابعی که یک عدد را می‌پذیرد و آن را با 100 مقایسه می‌کند، که دقیقاً آنچه را که در مثال خود می‌خواستیم به دست آوریم. به عبارت دیگر، تعریف زیر و تعریف قبلی ما معادل هستند:

```
compareWithHundred :: Int -> Ordering
compareWithHundred = compare 100
```

تعریف نوع همچنان همان می‌ماند، زیرا compare 100 یک تابع را برمی‌گرداند. compare دارای نوع (Ord a) => a -> (a -> Ordering) است. هنگامی که آن را بر روی 100 اعمال می‌کنیم، یک تابع را دریافت می‌کنیم که یک عدد را می‌پذیرد و یک مقدار Ordering را برمی‌گرداند.


Sections


توابع Infix همچنین می‌توانند با استفاده از بخش‌ها به صورت جزئی اعمال شوند. برای بخش بندی یک تابع Infix، به سادگی آن را با پرانتز در بیاورید و پارامتر را فقط در یکی از دو طرف قرار دهید. این عمل یک تابع ایجاد می‌کند که یک پارامتر را می‌پذیرد و سپس آن را به سمتی که یک عملگر دیگر نیاز دارد، اعمال می‌کند. در زیر یک مثال بسیار ساده آمده است:
divideByTen :: (Floating a) => a -> a
divideByTen = (/10)
همانطور که در کد زیر می‌بینید، فراخوانی divideByTen 200 معادل با فراخوانی 200 / 10 یا (/10) 200 است:

```
ghci> divideByTen 200
20.0
ghci> 200 / 10
20.0
ghci> (/10) 200
20.0
```

بیایید به یک مثال دیگر نگاهی بیندازیم. این تابع بررسی می‌کند که آیا یک کاراکتر ارائه شده به آن، یک حرف بزرگ است یا خیر:

```
isUpperAlphanum :: Char -> Bool
isUpperAlphanum = (`elem` ['A'..'Z'])
```

تنها چیزی که باید در مورد بخش‌ها توجه کنید، هنگام استفاده از اپراتور - (منفی یا تفریق) است. از تعریف بخش‌ها، (-4) می‌تواند منجر به ایجاد یک تابع شود که یک عدد را می‌پذیرد و 4 را از آن کم می‌کند. با این حال، به عنوان یک تسهیل، (-4) برابر با منفی چهار است. بنابراین، اگر می‌خواهید یک تابع ایجاد کنید که چهار را از عدد پارامتر دریافتی کم کند، می‌توانید تابع کم کردن را به صورت جزئی اعمال کنید، به این شکل: (subtract 4).


Printing Functions

تا به حال، ما توابعی که به صورت جزئی اعمال شده‌اند را به نام‌ها مرتبط کرده و سپس پارامترهای باقی‌مانده را ارائه داده‌ایم تا نتایج را مشاهده کنیم. با این حال، هیچ‌وقت سعی نکردیم توابع خود را به ترمینال چاپ کنیم. بیایید این کار را انجام دهیم، چه می‌شود اگر به جای مرتبط کردن آن با یک نام با let یا ارسال آن به یک تابع دیگر، سعی کنیم multThree 3 4 را در GHCi وارد کنیم؟

```
ghci> multThree 3 4
:1:0:
No instance for (Show (a -> a))
arising from a use of `print' at :1:0-12
Possible fix: add an instance declaration for (Show (a -> a))
In the expression: print it
In a 'do' expression: print it
```

GHCi به ما می‌گوید که عبارت یک تابع از نوع a -> a تولید کرده است، اما نمی‌داند چگونه آن را به صفحه نمایش ببرد. توابع نمونه‌های کلاس نوع Show نیستند، بنابراین نمی‌توانیم نمایش رشته‌ای دقیقی از یک تابع دریافت کنیم. این با مثال ورودی 1 + 1 در خط فرمان GHCi متفاوت است. در آن صورت، GHCi مقدار 2 را به عنوان نتیجه محاسبه می‌کند، و سپس show را بر روی 2 فراخوانی می‌کند تا یک نمایش متنی از آن عدد دریافت کند. نمایش متنی عدد 2 فقط رشته "2" است که سپس به صفحه نمایش چاپ می‌شود.
توجه کنید که حتما باید چگونگی کار توابع جزئی و تعریف توابع منحصر به فرد را به خوبی درک کنید، زیرا این موضوعات بسیار مهم هستند!


Some Higher-Orderism Is in Order

در Haskell، توابع می‌توانند توابع دیگر را به عنوان پارامترها دریافت کنند و همانطور که دیدید، می‌توانند توابع را به عنوان مقدار بازگشتی برگردانند. برای نشان دادن این مفهوم، بیایید یک تابع بنویسیم که یک تابع را دریافت کرده و آن را دو بار روی یک مقدار اعمال کند:

```
applyTwice :: (a -> a) -> a -> a
applyTwice f x = f (f x)
```

توجه کنید که در تعریف نوع، پرانتزها ضروری هستند. در مثال‌های قبلی ما، وقتی نوع توابع را تعریف می‌کردیم، نیازی به پرانتز نبود زیرا -> به طور طبیعی به صورت right-associative عمل می‌کند. با این حال، در اینجا پرانتزها اجباری هستند. آن‌ها نشان می‌دهند که پارامتر اول یک تابع است که یک پارامتر را دریافت می‌کند و یک مقدار با همان نوع (a -> a) را برمی‌گرداند. پارامتر دوم چیزی از نوع a است و نوع بازگشتی نیز a است. توجه کنید که این مهم نیست که نوع a چیست - می‌تواند Int، String یا هرچیز دیگری باشد - اما همه مقادیر باید همان نوع باشند.

توجه کنید که در پشت صحنه، توابعی که به نظر می‌رسد چندین پارامتر را می‌گیرند، در واقع یک پارامتر را گرفته و یک تابع جزئی اعمال شده را برمی‌گردانند. با این حال، برای سادگی، من همچنان می‌گویم که یک تابع خاص چندین پارامتر را می‌گیرد.
بدنه تابع applyTwice بسیار ساده است. ما فقط پارامتر f را به عنوان یک تابع استفاده می‌کنیم و x را با جدا کردن f و x با یک فاصله اعمال می‌کنیم. سپس نتیجه را دوباره به f اعمال می‌کنیم. در ادامه، چند مثال از کارکرد تابع را مشاهده می‌کنید:

```
ghci> applyTwice (+3) 10
16
ghci> applyTwice (++ " HAHA") "HEY"
"HEY HAHA HAHA"
ghci> applyTwice ("HAHA " ++) "HEY"
"HAHA HAHA HEY"
ghci> applyTwice (multThree 2 2) 9
144
ghci> applyTwice (3:) [1]
[3,3,1]
```

عظمت و کاربردی بودن برنامه‌نویسی جزئی (Partial Application) آشکار است. اگر تابع ما نیاز به تابعی با یک پارامتر داشته باشد، ما می‌توانیم تابعی را به صورت جزئی به نقطه‌ای برسانیم که فقط یک پارامتر را بپذیرد و سپس به آن بفرستیم. به عنوان مثال، تابع + دو پارامتر دارد و در این مثال، ما از بخش‌ها برای جزئی کردن آن استفاده کردیم تا فقط یک پارامتر را بپذیرد.


Implementing zipWith

حالا می‌خواهیم از برنامه‌نویسی بالاترین سطح استفاده کنیم تا یک تابع بسیار مفید در کتابخانه استاندارد به نام zipWith پیاده‌سازی کنیم. این تابع یک تابع و دو لیست به عنوان پارامتر دریافت می‌کند، سپس با اعمال تابع بین عناصر متناظر، دو لیست را به هم می‌پیوندد. به این صورت پیاده‌سازی می‌کنیم:

```
zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith' _ [] _ = []
zipWith' _ _ [] = []
zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys
```

ابتدا به تعریف نوع نگاه می‌کنیم. پارامتر اول تابعی است که دو آرگومان می‌گیرد و یک مقدار برمی‌گرداند. آن‌ها نیازی ندارند که از نوع یکسان باشند، اما می‌توانند باشند. پارامترهای دوم و سوم لیست هستند و مقدار برگشتی نیز یک لیست است.
لیست اول باید یک لیست از مقادیر نوع a باشد، زیرا تابع پیوستن مقدارهای a را به عنوان آرگومان اول خود می‌گیرد. لیست دوم باید یک لیست از نوع b باشد، زیرا پارامتر دوم تابع پیوستن نوع b است. نتیجه نیز یک لیست از عناصر نوع c است.

توجه کنید که اگر شما یک تابع (به خصوص یک تابع بالاترین سطح) را می‌نویسید و از نوع آن اطمینان ندارید، می‌توانید تعریف نوع را حذف کرده و با استفاده از دستور :t، نوعی که Haskell برای آن تعیین می‌کند را بررسی کنید.
این تابع شبیه به تابع zip معمولی است. موارد پایه نیز همان هستند، با این تفاوت که یک آرگومان اضافی وجود دارد (تابع پیوستن). با این حال، این آرگومان در موارد پایه مهم نیست، بنابراین می‌توانیم از کاراکتر _ برای آن استفاده کنیم. بدنه تابع در الگوی آخر نیز شبیه به zip است، اما به جای انجام (x، y)، f x y را انجام می‌دهد.
اینجا یک نمایش کوچک از تمام چیزهای مختلفی است که تابع zipWith' ما می‌تواند انجام دهد:

```
ghci> zipWith' (+) [4,2,5,6] [2,6,2,3]
[6,8,7,9]
ghci> zipWith' max [6,3,2,1] [7,3,1,5]
[7,3,2,5]
ghci> zipWith' (++) ["foo ", "bar ", "baz "] ["fighters", "hoppers", "aldrin"]
["foo fighters","bar hoppers","baz aldrin"]
ghci> zipWith' (*) (replicate 5 2) [1..]
[2,4,6,8,10]
ghci> zipWith' (zipWith' (*)) [[1,2,3],[3,5,6],[2,3,4]] [[3,2,2],[3,4,5],[5,4,3]]
[[3,4,6],[9,20,30],[10,12,12]]
```

همانطور که مشاهده می‌کنید، یک تابع بالاترین سطح می‌تواند به روش‌های بسیار متنوعی استفاده شود.



Implementing flip

حالا یک تابع دیگر در کتابخانه استاندارد به نام flip پیاده‌سازی می‌کنیم. تابع flip یک تابع را می‌گیرد و یک تابع را برمی‌گرداند که شبیه تابع اصلی ما است، اما با تغییر ترتیب دو آرگومان اول. می‌توانیم آن را به این صورت پیاده‌سازی کنیم:

```
flip' :: (a -> b -> c) -> (b -> a -> c)
flip' f = g
where g x y = f y x
```

از تعریف نوع می‌توانید ببینید که flip' یک تابع را که از نوع‌های a و b استفاده می‌کند، می‌گیرد و یک تابع را که از نوع‌های b و a استفاده می‌کند، برمی‌گرداند. اما به دلیل اینکه توابع به صورت پیوسته به‌کار می‌روند، جفت دومین پرانتز در واقع لازم نیست. پرانتز -> به‌طور پیش‌فرض به صورت راست به چپ است، بنابراین (a -> b -> c) -> (b -> a -> c) با (a -> b -> c) -> (b -> (a -> c)) برابر است، که با (a -> b -> c) -> b -> a -> c برابر است. ما g x y = f y x را نوشتیم. اگر این درست باشد، آیا f y x = g x y هم درست نیست؟ با در نظر گرفتن این موضوع، می‌توانیم این تابع را با روشی حتی ساده‌تر تعریف کنیم:

```
flip' :: (a -> b -> c) -> b -> a -> c
flip' f y x = f x y
```

در این نسخه جدید flip'، از این ویژگی استفاده می‌کنیم که توابع به صورت پیوسته هستند. هنگامی که flip' f را بدون پارامترهای y و x صدا می‌زنیم، یک f را برمی‌گرداند که دو پارامتر را می‌گیرد اما آن‌ها را به صورت معکوس فراخوانی می‌کند.
اگرچه توابع معکوس عموماً به توابع دیگر منتقل می‌شوند، ما می‌توانیم از پیوستگی استفاده کنیم و در هنگام ساخت توابع بالاترین سطح با تفکری پیشروی، نتیجه نهایی آن‌ها را در صورت اعمال کامل تصور کرده و آن‌ها را بنویسیم.

```
ghci> zip [1,2,3,4,5] "hello"
[(1,'h'),(2,'e'),(3,'l'),(4,'l'),(5,'o')]
ghci> flip' zip [1,2,3,4,5] "hello"
[('h',1),('e',2),('l',3),('l',4),('o',5)]
ghci> zipWith div [2,2..] [10,8,6,4,2]
[0,0,0,0,1]
ghci> zipWith (flip' div) [2,2..] [10,8,6,4,2]
[5,4,3,2,1]
```

اگر تابع zip را معکوس کنیم، یک تابع را که شبیه به zip است، با این تفاوت که آیتم‌های لیست اول در بخش دوم تاپل‌ها قرار داده می‌شوند و بالعکس، دریافت می‌کنیم. تابع flip' div پارامتر دوم خود را می‌گیرد و آن را بر پارامتر اول تقسیم می‌کند، بنابراین وقتی اعداد 2 و 10 به flip' div ارسال می‌شوند، نتیجه مانند استفاده از div 10 2 است.


The Functional Programmer’s Toolbox

به عنوان برنامه‌نویسان تابعی، به ندرت می‌خواهیم روی یک مقدار عمل کنیم. معمولاً می‌خواهیم یک مجموعه از اعداد، حروف یا هر نوع داده دیگری را بگیریم و آن‌ها را تبدیل کنیم تا نتایج خود را بسازیم. در این بخش، به بررسی برخی از توابع مفید که به ما کمک می‌کنند با چندین مقدار کار کنیم، خواهیم پرداخت.

The map Function

تابع map یک تابع و یک لیست را می‌گیرد و آن تابع را برای هر عنصر در لیست اعمال کرده و یک لیست جدید ایجاد می‌کند. این تابع به صورت زیر تعریف شده است:
map :: (a -> b) -> [a] -> [b]
map _ [] = []
map f (x:xs) = f x : map f xs
امضای نوع می‌گوید که map یک تابع از a به b و یک لیست از مقادیر a را می‌گیرد و یک لیست از مقادیر b برمی‌گرداند.
تابع map یک تابع بالاترین سطح چند منظوره است که می‌توان از آن در راه‌های مختلفی استفاده کرد. در اینجا نمونه کاربرد آن آمده است:

```
ghci> map (+3) [1,5,3,1,6]
[4,8,6,4,9]
ghci> map (++ "!") ["BIFF", "BANG", "POW"]
["BIFF!","BANG!","POW!"]
ghci> map (replicate 3) [3..6]
[[3,3,3],[4,4,4],[5,5,5],[6,6,6]]
ghci> map (map (^2)) [[1,2],[3,4,5,6],[7,8]]
[[1,4],[9,16,25,36],[49,64]]
ghci> map fst [(1,2),(3,5),(6,3),(2,6),(2,5)]
[1,3,6,2,2]
```
بله، شما احتمالاً متوجه شده‌اید که هر یک از این مثال‌ها می‌توانست با یک comprehension لیست نیز به دست آید. به عنوان مثال، map (+3) [1،5،3،1،6] به طور فنی با [x + 3 | x <- [1،5،3،1،6]] یکسان است. با این حال، استفاده از تابع map کد شما را قابل خواندن‌تر می‌کند، به ویژه زمانی که با نقشه‌های نقشه سروکار دارید.


The filter Function

تابع filter یک پیش‌بینی و یک لیست دریافت می‌کند و لیست عناصری را که این پیش‌بینی را برآورده می‌کنند، برمی‌گرداند. (به یاد داشته باشید که یک پیش‌بینی یک تابع است که مشخص می‌کند چیزی درست یا غلط است؛ به عبارت دیگر، یک تابعی که مقدار بولینی برمی‌گرداند.) امضای نوع و پیاده‌سازی به این صورت است:

```
filter :: (a -> Bool) -> [a] -> [a]
filter _ [] = []
filter p (x:xs)
| p x
= x : filter p xs
| otherwise = filter p xs
```

اگر p x به صورت درست برآورده شود، عنصر در لیست جدید قرار می‌گیرد. اگر به صورت درست برآورده نشود، در لیست جدید قرار نمی‌گیرد.
در زیر چند مثال از تابع filter آمده است:

```
ghci> filter (>3) [1,5,3,2,1,6,4,3,2,1]
[5,6,4]
ghci> filter (==3) [1,2,3,4,5]
[3]
ghci> filter even [1..10]
[2,4,6,8,10]
ghci> let notNull x = not (null x) in filter notNull [[1,2,3],[],[3,4,5],[2,2],[],[],[]]
[[1,2,3],[3,4,5],[2,2]]
ghci> filter (`elem` ['a'..'z']) "u LaUgH aT mE BeCaUsE I aM diFfeRent"
"uagameasadifeent"
ghci> filter (`elem` ['A'..'Z']) "i LAuGh at you bEcause u R all the same"
"LAGER"
```

همانند تابع map، تمام این مثال‌ها می‌توانستند با استفاده از پیش‌بینی‌ها و comprehensions لیست به دست آیند. هیچ قانون مشخصی برای زمان استفاده از map و filter در مقابل استفاده از comprehensions لیست وجود ندارد. شما باید بر اساس کد و متناسب با متن تصمیم بگیرید کدام یک قابل خواندن‌تر است.

تابع filter معادل استفاده از چندین پیش‌بینی در یک comprehension لیست است. این کار را می‌توان با فیلتر کردن چندین بار یا اتصال پیش‌بینی‌ها با تابع منطقی && انجام داد. در اینجا یک مثال آمده است:

```
ghci> filter (<15) (filter even [1..20])
[2,4,6,8,10,12,14]
```

در این مثال، لیست [1..20] را فیلتر می‌کنیم تا تنها اعداد زوج باقی بمانند. سپس این لیست را به filter (<15) منتقل می‌کنیم تا اعداد 15 و بالاتر را حذف کنیم. نسخه comprehension لیست به شکل زیر است:
```
ghci> [x | x <- [1..20], x < 15, even x]
[2,4,6,8,10,12,14]
```
در اینجا از یک comprehension لیست استفاده می‌کنیم که از لیست [1..20] برمی‌آییم و سپس شرایطی را که باید برای یک عدد در لیست نتیجه باید برقرار باشد، مشخص می‌کنیم.
آیا به تابع quicksort از فصل چهار نیز یاد می‌آورید؟ ما از comprehensions لیست برای فیلتر کردن عناصر لیست استفاده کردیم که کوچکتر (یا مساوی) یا بزرگتر از pivot بودند. می‌توانیم با استفاده از تابع filter به صورت قابل خواندن‌تری همان کار را انجام دهیم:

```
quicksort :: (Ord a) => [a] -> [a]
quicksort [] = []
quicksort (x:xs) =
let smallerOrEqual = filter (<= x) xs
larger = filter (> x) xs
in quicksort smallerOrEqual ++ [x] ++ quicksort larger
```


More Examples of map and filter

این مثال دیگری است که می‌خواهیم بزرگترین عدد کوچکتر از ۱۰۰،۰۰۰ را پیدا کنیم که بر ۳،۸۲۹ بخش‌پذیر است. برای این کار، مجموعه‌ای از احتمالاتی که می‌دانیم جواب در آنها وجود دارد، فیلتر می‌کنیم: 

```
largestDivisible :: Integer 
largestDivisible = head (filter p [100000,99999..]) 
where p x = x `mod` 3829 == 0 
```

ابتدا، لیستی نزولی از تمام اعداد کوچکتر از ۱۰۰،۰۰۰ می‌سازیم. سپس آن را با پیش‌بینی ما فیلتر می‌کنیم. با توجه به این که اعداد به صورت نزولی مرتب شده‌اند، بزرگترین عددی که شرط ما را برآورده می‌کند، اولین عضو لیست فیلتر شده خواهد بود. و به دلیل این که فقط سرآیند لیست فیلتر شده را استفاده می‌کنیم، این مهم نیست که لیست فیلتر شده محدود یا نامحدود باشد. تنبلی هسکل باعث می‌شود که ارزیابی زمانی متوقف شود که اولین جواب مناسب پیدا شود.


در مثال بعدی خود، ما مجموع تمام مربع‌های فردی را که کوچکتر از ۱۰،۰۰۰ هستند پیدا خواهیم کرد. در راه‌حل خود، از تابع takeWhile استفاده خواهیم کرد. این تابع یک پیش‌بینی و یک لیست دریافت می‌کند. با شروع از ابتدای لیست، عناصر لیست را تا زمانی که پیش‌بینی درست باشد برمی‌گرداند. هنگامی که یک عنصر یافت شود که پیش‌بینی درست نباشد، تابع متوقف می‌شود و لیست نتیجه را برمی‌گرداند. به عنوان مثال، برای گرفتن اولین کلمه یک رشته، می‌توانیم به صورت زیر عمل کنیم:

```
ghci> takeWhile (/=' ') "elephants know how to party"
"elephants"
```

برای پیدا کردن مجموع تمام مربع‌های فرد کوچکتر از ۱۰،۰۰۰، با اعمال تابع (^2) بر روی لیست بینهایت [1..] شروع می‌کنیم. سپس این لیست را فیلتر می‌کنیم تا فقط عناصر فرد را دریافت کنیم. بعد، با استفاده از takeWhile، عناصری از این لیست را تنها در حالی که کوچکتر از ۱۰،۰۰۰ هستند، دریافت می‌کنیم. در نهایت، مجموع این لیست را با استفاده از تابع sum محاسبه می‌کنیم. حتی نیازی به تعریف یک تابع برای این مثال نیست، زیرا می‌توانیم همه‌ی این کارها را در یک خط در GHCi انجام دهیم:

```
ghci> sum (takeWhile (<10000) (filter odd (map (^2) [1..])))
166650
```

عالی! ما با داده اولیه‌ای شروع می‌کنیم (لیست بی‌پایان تمام اعداد طبیعی) و سپس آن را نقشه برداری، فیلتر کردیم و به نیازهای خودمان تنظیم می‌کنیم. در نهایت، آن را مجموع می‌کنیم! ما همچنین می‌توانیم این مثال را با استفاده از ترکیب لیست، مانند این نوشته شود:

```
ghci> sum (takeWhile (<10000) [m | m <- [n^2 | n <- [1..]], odd m])
166650
```

در مسئله بعدی ما با توالی کولاتز سر و کار خواهیم داشت. توالی کولاتز (یا همان زنجیره کولاتز) به شرح زیر تعریف می‌شود: • با هر عدد طبیعی شروع کنید. • اگر عدد 1 باشد، متوقف شوید. • اگر عدد زوج باشد، آن را به 2 تقسیم کنید. • اگر عدد فرد باشد، آن را در 3 ضرب کرده و 1 را به آن اضافه کنید. • الگوریتم را با عدد حاصل از این محاسبه تکرار کنید. در واقع، این به ما یک زنجیره‌ی اعداد می‌دهد. ریاضی‌دانان نظریه می‌کنند که برای همه‌ی اعداد شروعی، زنجیره به عدد 1 ختم می‌شود. به عنوان مثال، اگر با عدد 13 شروع کنیم، این توالی را خواهیم داشت: 13، 40، 20، 10، 5، 16، 8، 4، 2، 1. (13 × 3 + 1 برابر با 40 است. 40 به 2 تقسیم شده برابر با 20 است و به همین ترتیب.) می‌توانیم ببینیم که زنجیره‌ای که با عدد 13 شروع می‌شود، دارای 10 عنصر است.


اینجا مشکلی را که می‌خواهیم حل کنیم بیان کرده‌ایم: برای تمامی اعداد شروع بین ۱ تا ۱۰۰، چند زنجیره کولاتز با طول بیشتر از ۱۵ داریم؟
گام اول ما نوشتن یک تابع است که زنجیره مورد نظر را تولید می‌کند:

```
chain :: Integer -> [Integer]
chain 1 = [1]
chain n
| even n = n:chain (n div 2)
| odd n = n:chain (n*3 + 1)
```

این تابع بازگشتی است و به صورت استاندارد نوشته شده است. حالت پایه‌ی آن یک است، زیرا همه‌ی زنجیره‌های ما در نهایت در عدد ۱ ختم می‌شوند. می‌توانیم تابع را تست کنیم تا ببینیم که به درستی کار می‌کند:

```
ghci> chain 10
[10,5,16,8,4,2,1]
ghci> chain 1
[1]
ghci> chain 30
[30,15,46,23,70,35,106,53,160,80,40,20,10,5,16,8,4,2,1]
```

حال می‌توانیم تابع numLongChains را بنویسیم که در واقع به سوال ما پاسخ می‌دهد:

```
numLongChains :: Int
numLongChains = length (filter isLong (map chain [1..100]))
where isLong xs = length xs > 15
```

ما تابع chain را به لیست [1..100] نگاشت می‌دهیم تا یک لیست از زنجیره‌ها که خودشان به صورت لیست نمایش داده می‌شوند، بدست آوریم. سپس آن‌ها را با یک پیش‌فیلتر فیلتر می‌کنیم که بررسی می‌کند طول یک لیست بیشتر از ۱۵ باشد. بعد از فیلتر کردن، تعداد زنجیره‌های باقی‌مانده را در لیست حاصل شده بررسی می‌کنیم.

توجه کنید که این تابع نوع numLongChains :: Int را دارد چون length عدد صحیح (Int) را برمی‌گرداند به جای Num a. اگر می‌خواستیم یک Num a کلی‌تر برگردانیم، می‌توانستیم از تابع fromIntegral بر روی طول حاصل استفاده کنیم.

Mapping Functions with Multiple Parameters

تا به حال ما تابع‌هایی را که فقط یک پارامتر دارند (مانند map (2) [0..]) نگاشته‌ایم. با این حال، می‌توانیم تابع‌هایی را که چندین پارامتر دارند هم نگاشت کنیم. به عنوان مثال، می‌توانیم شیوه‌ای را مانند map () [0..] استفاده کنیم. در این صورت، تابع * که نوع خود را به این شکل دارد (Num a) => a -> a -> a، برای هر عدد در لیست اعمال می‌شود.

همانطور که دیدید، دادن فقط یک پارامتر به یک تابع که دو پارامتر دارد، باعث بازگرداندن یک تابع می‌شود که فقط یک پارامتر دارد. بنابراین اگر ما * را به لیست [0..] نگاشت کنیم، یک لیست از توابعی که فقط یک پارامتر دارند، دریافت خواهیم کرد.


اینجا یک مثال است:

```
ghci> let listOfFuns = map (*) [0..]
ghci> (listOfFuns !! 4) 5
20
```

گرفتن المان با شاخص 4 از لیست ما، یک تابع را به ما بازمی‌گرداند که معادل (4*) است. سپس ما فقط 5 را به آن تابع اعمال می‌کنیم، که برابر با (4*) 5، یا فقط 4* 5 است.


Lambdas

لامبدا‌ها توابع بدون نام هستند که زمانی استفاده می‌شوند که نیاز به یک تابع فقط یک بار داشته باشیم. به طور معمول، لامبدا را با هدف اصلی ارسال آن به یک تابع با سفارشی بالاتر برای استفاده یک بار ایجاد می‌کنیم. برای تعریف یک لامبدا، با نوشتن علامت \ (زیرا این شکلی مانند حرف یونانی λ به نظر می‌رسد اگر به اندازه کافی خیره به آن نگاه کنید)، پارامترهای تابع را با فاصله جدا می‌نویسیم. بعد از آن کاراکتر -> و بدنه تابع نوشته می‌شود. ما معمولا لامبداها را با پرانتزها محاصره می‌کنیم. در بخش قبل، یک where binding در تابع numLongChains برای ایجاد تابع isLong برای هدف اصلی ارسال آن به filter استفاده کردیم. به جای این کار، ما می‌توانیم از یک لامبدا استفاده کنیم، مانند این:

```
numLongChains :: Int
numLongChains = length (filter (\xs -> length xs > 15) (map chain [1..100]))
```

لامبدا‌ها عبارت‌هایی هستند، به همین دلیل می‌توانیم به راحتی آن‌ها را به توابع ارسال کنیم. عبارت (\xs -> length xs > 15) یک تابع را به ما باز می‌گرداند که بررسی می‌کند آیا طول لیستی که به آن داده می‌شود بیشتر از ۱۵ است یا خیر.

افرادی که چگونگی عملکرد currying و partial application را درک نکرده‌اند، اغلب در جایی که لامبدا لازم نیست، از آن استفاده می‌کنند. به عنوان مثال، عبارات زیر معادل هم هستند:

```
ghci> map (+3) [1,6,3,2]
[4,9,6,5]
ghci> map (\x -> x + 3) [1,6,3,2]
[4,9,6,5]
```

هر دو (+3) و (\x -> x + 3) توابعی هستند که یک عدد را دریافت کرده و عدد ۳ را به آن اضافه می‌کنند. بنابراین، این عبارات نتایج یکسانی را تولید می‌کنند. با این حال، در این مورد نمی‌خواهیم یک لامبدا بسازیم، زیرا استفاده از partial application خواناتر است.
مانند توابع معمول، لامبداها می‌توانند هر تعداد پارامتر را دریافت کنند:

```
ghci> zipWith (\a b -> (a * 30 + 3) / b) [5,4,3,2,1] [1,2,3,4,5]
[153.0,61.5,31.0,15.75,6.6]
```

و مانند توابع معمول، می‌توانید در لامبداها از pattern match استفاده کنید. تنها تفاوت این است که نمی‌توانید چند pattern برای یک پارامتر تعریف کنید (مثلاً الگوی [] و (x:xs) را برای یک پارامتر تعریف کنید و سپس مقادیر را از بین بروند).

```
ghci> map ((a,b) -> a + b) [(1,2),(3,5),(6,3),(2,6),(2,5)]
[3,8,9,8,7]
```

توجه: در صورت شکست pattern match در قالب یک لامبدا، خطای runtime رخ می‌دهد، لذا دقت کنید!
بیایید به یک مثال دیگر جالب نگاه کنیم:

```
addThree :: Int -> Int -> Int -> Int
addThree x y z = x + y + z
addThree :: Int -> Int -> Int -> Int
addThree' = \x -> \y -> \z -> x + y + z
```

به دلیل اینکه توابع به طور پیش فرض توسط currying کار می‌کنند، این دو تابع معادل هستند. با این حال، تابع اول addThree بسیار خواناتر است. تابع دوم تقریباً یک کلاهبرداری است تا currying را نشان دهد.

توجه:
توجه کنید که در مثال دوم، لامبداها با پرانتز محاصره نشده‌اند. هنگامی که یک لامبدا را بدون پرانتز می‌نویسید، فرض می‌شود همه چیز در سمت راست علامت -> برای آن است. بنابراین در این مورد، حذف پرانتز در واقع کمی تایپ را صرفه جویی می‌کند. البته، اگر از پرانتزها خوشتان می‌آید، می‌توانید آن‌ها را نیز بگنجانید.
با این حال، در برخی موارد استفاده از نمایش currying مفید است. من فکر می‌کنم تابع flip هنگامی که به این صورت تعریف می‌شود، خواناترین است:

```
flip' :: (a -> b -> c) -> b -> a -> c
flip' f = \x y -> f y x
```

اگر چه این با نوشتن flip' f x y = f y x همان است، اما notation جدید ما بیانگر آن است که این معمولاً برای تولید یک تابع جدید استفاده می‌شود. استفاده رایج‌ترین از flip در فراخوانی با فقط پارامتر تابع، یا پارامتر تابع و یک پارامتر اضافی است و سپس تابع حاصل را به map یا zipWith منتقل می‌کنیم:

```
ghci> zipWith (flip (++)) ["love you", "love me"] ["i ", "you "]
["i love you","you love me"]
ghci> map (flip subtract 20) [1,2,3,4]
[19,18,17,16]
```

شما می‌توانید در توابع خود از این نوع لامبداها استفاده کنید، زمانی که می‌خواهید صریحاً بیان کنید که توابع شما برای استفاده یکباره و سپس انتقال آن‌ها به توابع دیگر به عنوان پارامتر هستند.


I Fold You So

وقتی ما در فصل چهار با بازگشت درگیر بودیم، بسیاری از توابع بازگشتی که بر روی لیست ها عمل می کردند، الگوی مشابهی دنبال می کردند. ما برای لیست خالی یک حالت پایه داشتیم، الگوی x:xs را معرفی کردیم و سپس عملی را انجام دادیم که شامل یک المان واحد و بقیه لیست بود. به نظر می رسد که این یک الگوی بسیار رایج است، بنابراین خالقان زبان هسکل توابع مفیدی به نام "fold" را معرفی کردند تا آن را تجمع دهند. با استفاده از "fold" می توانید یک ساختار داده (مانند یک لیست) را به یک مقدار واحد کاهش دهید.

"Folds" می توانند برای پیاده سازی هر تابعی که یک بار لیست را از المان به المان بگذرانید و سپس بر اساس آن چیزی را برگردانید، استفاده شوند. هرگاه که می خواهید یک لیست را برای برگرداندن چیزی طی کنید، احتمالاً می خواهید از "fold" استفاده کنید.

عملیات "fold" یک تابع دودویی (تابعی که دو پارامتر مثل "+" و "/" را دریافت می کند)، یک مقدار شروع (معمولاً به عنوان "تجمع کننده" شناخته می شود) و یک لیست برای تجمع دادن، در خود جای می دهد. لیست ها می توانند از چپ یا راست تجمع داده شوند. تابع "fold" با استفاده از تابع دودویی داده شده، با استفاده از تجمع کننده و المان اول (یا آخرین) لیست به عنوان پارامترها، فراخوانی می شود. مقدار حاصل، تجمع کننده جدید است. سپس تابع "fold" با استفاده از تابع دودویی مجدداً با تجمع کننده جدید و المان اول (یا آخرین) لیست فراخوانی می شود و نتیجه آن یک تجمع کننده جدید است. این عمل، تا زمانی که تابع به طول کامل لیست برسد و آن را به یک مقدار تجمع دهنده واحد کاهش دهد، تکرار می شود.


Left Folds with foldl


ابتدا، به تابع "foldl" نگاه کنیم. این تابع یک تابع پایه به نام "left fold" است، زیرا لیست را از سمت چپ جمع می کند. در این حالت، تابع دودویی بین تجمع کننده ابتدایی و سر لیست اعمال می شود. این عمل مقدار جدیدی از تجمع کننده را ایجاد می کند و تابع دودویی با آن مقدار و المان بعدی فراخوانی می شود و به همین ترتیب ادامه پیدا می کند.

حالا بیایید دوباره تابع sum را پیاده سازی کنیم، این بار با استفاده از "fold" به جای بازگشت صریح:

```
sum' :: (Num a) => [a] -> a
sum' xs = foldl (\acc x -> acc + x) 0 xs
```

حال می‌توانیم آن را تست کنیم:

```
ghci> sum' [3,5,2,1]
11
```

بیایید به صورت جزئیات تر نگاهی به این fold بیندازیم. \acc x -> acc + x تابع دودویی است. 0 مقدار شروع و xs لیستی است که باید تجمع داده شود. ابتدا، 0 و 3 به تابع دودویی به عنوان پارامترهای acc و x فرستاده می شوند. در این حالت، تابع دودویی به سادگی یک جمع است، بنابراین دو مقدار با هم جمع می شوند که 3 را به عنوان مقدار تجمع دهنده جدید تولید می کند. بعد، 3 و مقدار بعدی لیست (5) به عنوان پارامترهای acc و x به تابع دودویی فرستاده می شوند و با هم جمع می شوند تا مقدار تجمع دهنده جدید 8 شود. به همین شکل، 8 و 2 با هم جمع شده و مقدار 10 را تولید می کنند، و سپس 10 و 1 با هم جمع شده و مقدار نهایی 11 را تولید می کنند. تبریک می گویم، شما لیست اول خود را تجمع دادید!

نمودار سمت چپ نشان می دهد که چگونه fold به صورت گام به گام انجام می شود. عددی که در سمت چپ "+" است، مقدار تجمع دهنده است. می توانید ببینید که تجمع دهنده از سمت چپ با لیست مصرف می شود.

اگر وجود داشته باشد که توابع curried هستند، می توانیم پیاده سازی را به صورت مختصرتری بنویسیم، به این شکل:

```
sum' :: (Num a) => [a] -> a
sum' = foldl (+) 0
```

تابع lambda (\acc x -> acc + x) همان (+) است. می توانیم پارامتر xs را حذف کنیم زیرا فراخوانی foldl (+) 0 یک تابعی را باز می گرداند که یک لیست را می پذیرد. به طور کلی، اگر یک تابع مانند foo a = bar b a داشته باشید، می توانید آن را به صورت foo = bar b نوشته و از currying استفاده کنید.


Right Folds with foldr


تابع right fold، foldr، شبیه به left fold است، با این تفاوت که تجمع دهنده مقادیر را از سمت راست می‌خورد. همچنین، ترتیب پارامترها در تابع دودویی right fold برعکس است: مقدار فعلی لیست اولین پارامتر است و تجمع دهنده دومین پارامتر است. (منطقی است که تجمع دهنده در right fold در سمت راست قرار دارد زیرا از سمت راست جمع می‌گردد.)

مقدار تجمع دهنده (و به تبع آن، نتیجه) یک fold می‌تواند هر نوعی باشد. می‌تواند یک عدد، یک بولین یا حتی یک لیست جدید باشد. به عنوان مثال، بیایید تابع map را با یک right fold پیاده‌سازی کنیم. تجمع دهنده یک لیست خواهد بود و ما لیست Map شده را المان به المان جمع آوری خواهیم کرد. البته، عنصر شروع ما باید یک لیست خالی باشد:

```
map' :: (a -> b) -> [a] -> [b]
map' f xs = foldr (\x acc -> f x : acc) [] xs
```

اگر (+3) را به [1،2،3] نگاه کنیم، از سمت راست به لیست نزدیک می شویم. آخرین عنصر را، که 3 است، دریافت کرده و تابع را بر روی آن اعمال می کنیم که 6 را تولید می کند. سپس آن را به تجمع دهنده یعنی [] قرار میدهیم. 6:[] برابر با [6] است، بنابراین این حالت حالت تجمع دهنده جدید است. سپس (+3) را به 2 اعمال می کنیم و مقدار 5 را تولید می کنیم و (:)-روی آن قرار می دهیم. مقدار تجمع دهنده جدید ما برابر با [5،6] است. سپس (+3) را به 1 اعمال کرده و نتیجه را دوباره به تجمع دهنده اضافه می کنیم، که نتیجه نهایی برابر با [4،5،6] است.

البته، این تابع را می توانیم با left fold پیاده سازی کنیم:

```
map' :: (a -> b) -> [a] -> [b]
map' f xs = foldl (\acc x -> acc ++ [f x]) [] xs
```

با این حال، تابع ++ از : بسیار کندتر است، بنابراین معمولاً هنگام ساختن لیست جدید از یک لیست از right fold استفاده می‌کنیم.
یک تفاوت بزرگ بین دو نوع fold این است که right fold بر روی لیست‌های بی نهایت کار می‌کند، در حالی که fold های چپی این کار را نمی‌کنند!
بیایید یک تابع دیگر با یک right fold پیاده‌سازی کنیم. همانطور که می‌دانید، تابع elem بررسی می‌کند که یک مقدار بخشی از یک لیست باشد یا نه. اینجا نحوه استفاده از foldr برای پیاده‌سازی آن را مشاهده می‌کنید:

```
elem' :: (Eq a) => a -> [a] -> Bool
elem' y ys = foldr (\x acc -> if x == y then True else acc) False ys
```

در اینجا، مقدار اکومولاتور یک مقدار بولین است. (به‌خاطر داشته باشید که همیشه در مورد fold ها، نوع مقدار اکومولاتور و نوع نتیجه نهایی یکسان هستند.) ما با یک مقدار False شروع می‌کنیم، زیرا فرض می‌کنیم که مقدار در لیست وجود ندارد. این همچنین مقدار درست را به ما در صورتی که آن را بر روی لیست خالی فراخوانی کنیم، می‌دهد، زیرا فراخوانی یک fold بر روی یک لیست خالی، فقط مقدار شروع را برمی‌گرداند.

سپس، ما بررسی می‌کنیم که آیا عنصر فعلی عنصری است که می‌خواهیم. اگر بله، مقدار اکومولاتور را به True تنظیم می‌کنیم. اگر خیر، فقط اکومولاتور را بدون تغییر رها می‌کنیم. اگر قبلاً False بود، همانطور که الان هم هست، برای اینکه این عنصر فعلی مورد نظر ما نیست، همچنان False باقی می‌ماند. اگر قبلاً True بود، همچنان True باقی می‌ماند، زیرا بقیه‌ی لیست با استفاده از fold بسته می‌شود.


The foldl and foldr1 Functions

توابع foldl1 و foldr1 شبیه به توابع foldl و foldr هستند، با این تفاوت که نیازی به تعیین اکومولاتور شروعی ندارند. آن‌ها فرض می‌کنند که اولین (یا آخرین) عنصر لیست به عنوان اکومولاتور شروعی استفاده شود و با عنصر بعدی آن شروع به اعمال fold می‌کنند. با توجه به این موضوع، تابع بیشینه می‌تواند به شکل زیر پیاده‌سازی شود:

```
maximum' :: (Ord a) => [a] -> a
maximum' = foldl1 max
```

ما بیشینه را با استفاده از foldl1 پیاده‌سازی کردیم. به جای تعیین اکومولاتور شروعی، foldl1 فقط اولین عنصر را به عنوان اکومولاتور شروعی فرض می‌کند و با عنصر بعدی شروع به اعمال fold می‌کند. بنابراین، تنها چیزی که برای عملکرد foldl1 نیاز داریم، تابع دوتایی و لیستی است که باید fold شود! ما از ابتدای لیست شروع کرده و هر عنصر را با اکومولاتور مقایسه می‌کنیم. اگر بزرگتر از اکومولاتور ما باشد، آن را به عنوان اکومولاتور جدید نگه می‌داریم؛ در غیر این صورت، اکومولاتور قبلی را نگه می‌داریم. ما max را به عنوان تابع دوتایی به foldl1 منتقل کردیم، زیرا دقیقاً همین کار را انجام می‌دهد: دو مقدار را می‌گیرد و بزرگترین آن‌ها را برمی‌گرداند. در زمانی که با fold کردن لیست خودمان به پایان رسیدیم، تنها عنصر بزرگترین باقی می‌ماند.
به دلیل وابستگی به حداقل یک عنصر در لیستی که با آن فراخوانی می‌شوند، این توابع در صورت فراخوانی با لیست‌های خالی، خطاهای زمان اجرا را ایجاد می‌کنند. از سوی دیگر، توابع foldl و foldr با لیست‌های خالی نیز مشکلی ندارند.

توجه: در هنگام اعمال fold، به این موضوع فکر کنید که آن چگونه با یک لیست خالی عمل می‌کند. اگر تابع با لیست خالی معنا نداشته باشد، احتمالاً می‌توانید از توابع foldl1 یا foldr1 برای پیاده‌سازی آن استفاده کنید.


Some Fold Examples

برای نشان دادن قدرت توابع fold، بیایید با استفاده از fold، برخی از توابع استاندارد کتابخانه را پیاده‌سازی کنیم. ابتدا، نسخه خودمان از تابع reverse را پیاده‌سازی می‌کنیم:

```
reverse' :: [a] -> [a]
reverse' = foldl (\acc x -> x : acc) []
```

در اینجا، ما با استفاده از لیست خالی به عنوان اکومولاتور شروعی، لیست را برعکس می‌کنیم و سپس با نزدیک شدن به لیست اصلی از سمت چپ، عنصر فعلی را در ابتدای اکومولاتور قرار می‌دهیم.




تابع \acc x -> x : acc همانند تابع : عمل می‌کند، با این تفاوت که پارامترهای آن به هم برعکس شده‌اند. به همین دلیل، ما می‌توانیم نسخه reverse' را به صورت زیر نیز پیاده‌سازی کنیم:

```
reverse' :: [a] -> [a]
reverse' = foldl (flip (:)) []
```

حال، ما تابع product را پیاده‌سازی می‌کنیم:

```
product' :: (Num a) => [a] -> a
product' = foldl (*) 1
```

برای محاسبه حاصلضرب تمامی اعداد موجود در لیست، ما با استفاده از ۱ به عنوان آکومولاتور شروع می‌کنیم. سپس با استفاده از تابع *، اعداد را با آکومولاتور ضرب می‌کنیم.

حال می‌خواهیم تابع filter را پیاده‌سازی کنیم:

````
filter' :: (a -> Bool) -> [a] -> [a]
filter' p = foldr (\x acc -> if p x then x : acc else acc) []
```

در اینجا، ما از یک لیست خالی به عنوان accumulator شروع می کنیم. سپس از راست تا چپ fold می کنیم و هر المان را بررسی می کنیم. p، پیش‌شرط ماست. اگر p x درست باشد - به معنای آن که پیش‌شرط برای المان فعلی درست باشد - آن را در ابتدای accumulator قرار می دهیم. در غیر این صورت، accumulator قدیمی را مجدداً استفاده می کنیم. در نهایت، ما last را پیاده‌سازی خواهیم کرد:

```
last' :: [a] -> a
last' = foldl1 (_ x -> x)
```

برای دریافت آخرین المان لیست، از foldl1 استفاده می کنیم. ما از المان اول لیست شروع می کنیم، سپس از یک تابع دودویی استفاده می کنیم که accumulator را نادیده می گیرد و همیشه المان فعلی را به عنوان accumulator جدید تنظیم می کند. یک‌بار که به انتها رسیدیم، accumulator - به عنوان آخرین المان - برگشت داده خواهد شد.


Another Way to Look at Folds

روش دیگری برای تصور fold های راست و چپ، به عنوان مستمری اعمال یک تابع به المان‌های یک لیست است. فرض کنید که ما یک fold راست با یک تابع دودویی f و یک accumulator اولیه z داریم. زمانی که ما روی لیست [3،4،5،6] fold راست انجام می‌دهیم، در واقع این کار را انجام می دهیم:

```
f 3 (f 4 (f 5 (f 6 z)))
```

تابع f با آخرین عنصر لیست و accumulator فراخوانی می شود و سپس این مقدار به عنوان accumulator به مقدار قبلی از سمت راست داده می شود و همین عملیات برای المان‌های قبلی نیز انجام می‌گیرد.
اگر ما f را به عنوان + و مقدار accumulator اولیه را به صفر در نظر بگیریم، این کار را انجام می دهیم:

```
3 + (4 + (5 + (6 + 0)))
```
یا اگر ما + را به صورت یک تابع پیشوندی بنویسیم، این کار را انجام می‌دهیم:

```
(+) 3 ((+) 4 ((+) 5 ((+) 6 0)))
```

به همین ترتیب، انجام یک fold چپ بر روی آن لیست با استفاده از g به عنوان تابع دودویی و z به عنوان accumulator، معادل این است:

```
g (g (g (g z 3) 4) 5) 6
```

اگر از flip (:) به عنوان تابع دودویی و [] به عنوان accumulator استفاده کنیم (بنابراین ما در حال برعکس کردن لیست هستیم)، معادل زیر است:

```
flip (:) (flip (:) (flip (:) (flip (:) [] 3) 4) 5) 6
```

و اگر این عبارت را ارزیابی کنید، شما خروجی [6،5،4،3] را دریافت خواهید کرد.


Folding Infinite Lists


درک Fold را به عنوان برنامه های کاربردی متوالی روی مقادیر لیست، می‌تواند برای شما نگاهی به این مسئله داشته باشد که چرا در برخی موارد foldr بر روی لیست‌های بی‌نهایت بدون مشکل کار می‌کند. ما تابع and را با استفاده از foldr پیاده‌سازی می‌کنیم و سپس آن را به صورت یک سری عملیات تابع متوالی نوشته و مثال‌های قبلی خودمان را دنبال می‌کنیم. در اینجا خواهید دید که چگونه foldr با تنبلی Haskell برای عملکرد در لیست‌هایی با طول بی‌نهایت کار می‌کند.

تابع and یک لیست از مقادیر Bool می‌گیرد و در صورتی که یک یا چند مورد از عناصر False باشد False برمی‌گرداند؛ در غیر این صورت True برمی‌گرداند. ما از راست به چپ به لیست نزدیک می‌شویم و از True به عنوان accumulator شروع می‌کنیم. برای اینکه در نهایت تنها در صورتی که همه المان‌ها True باشند True بگردانیم، از && به عنوان binary function استفاده می‌کنیم. تابع && در صورتی که یکی از پارامترهای آن False باشد False را برمی‌گرداند. بنابراین، اگر با یک المان در لیست مواجه شویم که False باشد، accumulator به False تنظیم خواهد شد و در نهایت نتیجه نهایی False خواهد بود، حتی اگر تمام عناصر دیگر True باشند.

با درک اینکه Fold چگونه کار می‌کند، می‌توانیم ببینیم که عبارت and’ [True، False، True] به صورت زیر ارزیابی می‌شود:

```
True && (False && (True && True))
```

آخرین True نشان دهنده accumulator شروع ماست، در حالیکه سه مقدار Bool اول از لیست [True، False، True] هستند. در صورتی که سعی کنیم عبارت قبلی را ارزیابی کنیم، نتیجه False خواهیم گرفت.

حال فرض کنید این کار را با یک لیست بی‌نهایت به طول repeat False انجام دهیم. در این صورت، یک لیست بی‌نهایت از تعداد نامحدودی المان False داریم. اگر بخواهیم آن را بنویسیم، به شکل زیر خواهیم داشت:

```
False && (False && (False && (False ...
```

الف Haskell تنبل است، بنابراین فقط آنچه را که واقعاً باید محاسبه شود، محاسبه می‌کند. همچنین، تابع && به گونه‌ای کار می‌کند که در صورتی که پارامتر اول آن False باشد، از پارامتر دوم خود بی‌توجه خواهد شد زیرا تابع && فقط در صورتی True را برمی‌گرداند که هر دوی پارامترهایش True باشند:

```
(&&) :: Bool -> Bool -> Bool
True && x = x
False && _ = False
```

در مورد لیست بی‌نهایت از مقادیر False، الگوی دوم با آن مطابقت می‌کند و False بدون نیاز به ارزیابی بقیه لیست بی‌نهایت برگردانده می‌شود:

```
ghci> and' (repeat False)
False
```

الف Foldr زمانی کار می‌کند که تابع binary function که به آن می‌دهیم، برای دادن پاسخی به ما نیاز به همیشه ارزیابی پارامتر دوم خود نداشته باشد. به عنوان مثال، تابع && نگران پارامتر دوم خود نمی‌باشد اگر پارامتر اول آن False باشد.


Scans

توابع scanl و scanr شبیه به توابع foldl و foldr هستند، با این تفاوت که تمام حالت‌های accumulator میانی را به صورت یک لیست بازگردانده می‌شوند. توابع scanl1 و scanr1 نیز به foldl1 و foldr1 مشابه هستند. در زیر چند مثال از این توابع آورده شده است:

```
ghci> scanl (+) 0 [3,5,2,1]
[0,3,8,10,11]
ghci> scanr (+) 0 [3,5,2,1]
[11,8,3,1,0]
ghci> scanl1 (\acc x -> if x > acc then x else acc) [3,4,5,3,7,9,2,1]
[3,4,5,5,7,9,9,9]
ghci> scanl (flip (:)) [] [3,2,1]
[[],[3],[2,3],[1,2,3]]
```

در استفاده از scanl، نتیجه نهایی در آخرین المان لیست حاصل خواهد شد. scanr نتیجه را در سر لیست قرار می‌دهد.

اسکن‌ها برای نظارت بر پیشرفت یک تابع که می‌تواند به صورت یک fold پیاده‌سازی شود، استفاده می‌شوند. به عنوان یک تمرین در استفاده از اسکن‌ها، بیایید سعی کنیم به این سوال پاسخ دهیم: چند المان لازم است تا جمع ریشه مربعی همه اعداد طبیعی بیشتر از ۱٬۰۰۰ شود؟

برای گرفتن ریشه مربعی همه اعداد طبیعی، فقط کافیست map sqrt [1..] را فراخوانی کنیم. برای گرفتن جمع، می‌توانیم از یک fold استفاده کنیم. با این حال، زیرا در صورتی که ما به پیشرفت جمع علاقمند هستیم، از یک scan به جای fold استفاده خواهیم کرد. پس از انجام اسکن، می‌توانیم بررسی کنیم که چند جمع کوچکتر از ۱٬۰۰۰ هستند.

```
sqrtSums :: Int
sqrtSums = length (takeWhile (<1000) (scanl1 (+) (map sqrt [1..]))) + 1
```

در اینجا از takeWhile به جای filter استفاده می‌کنیم زیرا filter لیست حاصل را بعد از پیدا کردن یک عدد مساوی یا بیشتر از ۱٬۰۰۰ قطع نخواهد شد؛ به دنبال جستجو خواهد کرد. با اینکه ما می‌دانیم که لیست در حال صعود است، filter نمی‌داند، بنابراین از takeWhile برای قطع لیست اسکن به صورت اولین وقوع یک جمع بزرگتر از ۱٬۰۰۰ استفاده می‌کنیم.

اولین مجموع در لیست اسکن ۱ است. دومین مجموع ۱ به اضافه ریشه مربعی ۲ است. سومین مجموع آن به اضافه ریشه مربعی ۳ است. اگر x جمع کوچکتر از ۱٬۰۰۰ باشد، آنگاه برای جمع بیشتر از ۱٬۰۰۰ به x+1 عنصر نیاز است:

```
ghci> sqrtSums
131
ghci> sum (map sqrt [1..131])
1005.0942035344083
ghci> sum (map sqrt [1..130])
993.6486803921487
```

در نتیجه، پاسخ ما درست است! اگر ما ۱۳۰ ریشه مربعی را با هم جمع کنیم، نتیجه آن دقیقاً زیر ۱٬۰۰۰ خواهد بود، اما اگر یک عدد دیگر به آن اضافه کنیم، از آستانه ما عبور خواهیم کرد.


Function Application with $

حالا به بررسی تابع $، همچنین به عنوان اپراتور برنامه‌ریزی تابع شناخته می‌شود، خواهیم پرداخت. اول، بیایید ببینیم که چگونه تعریف شده است:

```
($) :: (a -> b) -> a -> b
f $ x = f x
```

آره ولش کن! این تابع بیهوده چیه؟ این فقط اپلیکیشن تابعه! خب، تقریباً درسته، اما نه کاملاً. در حالی که اپلیکیشن تابع عادی (قرار دادن یک فاصله بین دو چیز) اولویت بسیار بالایی دارد، تابع $ اولویت پایین‌تر را دارد. اپلیکیشن تابع با فاصله چپ-تبعیضی است (بنابراین f a b c همان ((f a) b) c است)، در حالی که اپلیکیشن تابع با $ راست-تبعیضی است.

پس چطور به ما کمک می‌کند؟ بیشتر اوقات، این یک تابع راحتی است که باعث می‌شود کمتر پرانتز نوشته شود. به عنوان مثال، عبارت sum (map sqrt [1..130]) را در نظر بگیرید. به دلیل اینکه $ اولویت خیلی پایینی دارد، می‌توانیم آن عبارت را به صورت sum $ map sqrt [1..130] بازنویسی کنیم. هنگامی که $ به عنوان اپراتور ملاقات می‌شود، عبارت سمت راست به عنوان پارامتر به تابع سمت چپ اعمال می‌شود.

چه طور sqrt 3 + 4 + 9؟ این ۹، ۴ و ریشه مربعی ۳ را به هم اضافه می‌کند. با این حال، اگر می‌خواستیم ریشه مربعی ۳ + ۴ + ۹ را داشته باشیم، باید sqrt (3 + 4 + 9) بنویسیم. با $، همچنین می‌توانیم آن را به صورت sqrt $ 3 + 4 + 9 بنویسیم. شما می‌توانید $ را تقریباً معادل با نوشتن پرانتز باز و سپس نوشتن پرانتز بسته در سمت راست عبارت تصور کنید.

بیایید به مثال دیگری نگاهی بیندازیم:

```
ghci> sum (filter (> 10) (map (*2) [2..10]))
80
```

وای، خیلی پرانتزها! کمی زشت به نظر می‌رسد. در اینجا، (*2) روی [2..10] نگاشت می‌شود، سپس لیست حاصل را فیلتر می‌کنیم تا تنها آن اعداد باشند که بزرگتر از ۱۰ هستند و در نهایت آن اعداد با هم جمع می‌شوند.

می‌توانیم از تابع $ استفاده کنیم تا مثال قبلی خود را بازنویسی کنیم و آن را کمی راحت‌تر برای چشمانمان کنیم:

```
ghci> sum $ filter (> 10) (map (*2) [2..10])
80
```

تابع $ راست-تبعیضی است، به این معنی که چیزی شبیه f $ g $ x برابر f $ (g $ x) است. با این در نظر داشت، مثال پیشین می‌تواند دوباره به صورت زیر بازنویسی شود:

```
ghci> sum $ filter (> 10) $ map (*2) [2..10]
80
```

به جز رها کردن پرانتز، $ به ما اجازه می‌دهد که اپلیکیشن تابع را مانند یک تابع دیگر در نظر بگیریم. با این کار، می‌توانیم به عنوان مثال اپلیکیشن تابع را روی یک لیست از توابع نگاشت کنیم، به شکل زیر:

```
ghci> map ($ 3) [(4+), (10*), (^2), sqrt]
[7.0,30.0,9.0,1.7320508075688772]
```

در اینجا، تابع ($ 3) روی لیست نگاشت می‌شود. اگر درباره اینکه تابع ($ 3) چه کار می‌کند فکر کنید، خواهید دید که این تابع یک تابع را می‌گیرد و سپس آن تابع را به ۳ اعمال می‌کند. بنابراین هر تابع در لیست با ۳ اعمال می‌شود، که در نتیجه مشخص است.


Function Composition


در ریاضیات، ترکیب توابع به این صورت تعریف می‌شود: (f ◦ g)(x) = f (g(x)). این بدان معناست که ترکیب دو تابع معادل است با فراخوانی یک تابع با یک مقدار و سپس فراخوانی دیگری با نتیجه فرستاده شده از تابع اول.

در Haskell، ترکیب توابع تقریباً همان چیزی است. با استفاده از تابع .، ما ترکیب تابع را انجام می‌دهیم، که به این صورت تعریف شده است:

```
(.) :: (b -> c) -> (a -> b) -> a -> c
f . g = \x -> f (g x)
```

نوع تعریف شده را توجه کنید. f باید به عنوان پارامتر خود یک مقداری را بگیرد که دارای همان نوع بازگشت g باشد. بنابراین تابع حاصل، پارامتری با همان نوعی که g می‌گیرد را می‌گیرد و یک مقدار از همان نوعی که f برمی‌گرداند را برمی‌گرداند. به عنوان مثال، عبارت negate . (* 3) یک تابع را برمی‌گرداند که یک عدد را می‌گیرد، آن را در ۳ ضرب می‌کند و سپس منفی می‌کند.

یک کاربرد از ترکیب تابع، ساخت توابع به صورت پویا برای ارسال به توابع دیگر است. البته، ما می‌توانیم از لامبدا برای این کار استفاده کنیم، اما بسیاری از مواقع، ترکیب تابع روشن‌تر و خلاصه‌تر است. به عنوان مثال، فرض کنید یک لیست از اعداد داشته باشیم و می‌خواهیم همه آن‌ها را به اعداد منفی تبدیل کنیم. یک روش برای انجام این کار این است که مقدار مطلق هر عدد را بگیریم و سپس آن را منفی کنیم، به شکل زیر:

```
ghci> map (\x -> negate (abs x)) [5,-3,-6,7,-3,2,-19,24]
[-5,-3,-6,-7,-3,-2,-19,-24]
```

توجه کنید که لامبدا چگونه شبیه نتیجه ترکیب تابع به نظر می‌رسد. با استفاده از ترکیب تابع، می‌توانیم آن را به صورت زیر بازنویسی کنیم:

```
ghci> map (negate . abs) [5,-3,-6,7,-3,2,-19,24]
[-5,-3,-6,-7,-3,-2,-19,-24]
```

عالی! ترکیب تابع راست-تبعیضی است، بنابراین می‌توانیم همزمان چندین تابع را ترکیب کنیم. عبارت f (g (z x)) برابر با (f . g . z) x است. با در نظر داشتن این موضوع، می‌توانیم چیزی پرهزینه مانند زیر را به شکل زیر بازنویسی کنیم:

```
ghci> map (\xs -> negate (sum (tail xs))) [[1..5],[3..6],[1..7]]
[-14,-15,-27]
```

این کد را می‌توان به شکل زیر که با کمک ترکیب تابع نوشته شده، بازنویسی کرد:

```
ghci> map (negate . sum . tail) [[1..5],[3..6],[1..7]]
[-14,-15,-27]
```

negate . sum . tail یک تابع است که یک لیست را می‌گیرد، تابع tail را به آن اعمال می‌کند، سپس تابع sum را به نتیجه حاصل از آن اعمال می‌کند و در نهایت، نتیجه قبلی را منفی می‌کند. بنابراین معادل با لامبدای پیشین است.


Function Composition with Multiple Parameters


اما چطور با توجه به اینکه برخی توابع چندین پارامتر می‌گیرند، می‌توانیم از آن‌ها در ترکیب تابع استفاده کنیم؟ به طور معمول باید آن‌ها را جزئیاً اعمال کرده و به هر تابع فقط یک پارامتر دهیم تا بتوانیم از آن‌ها در ترکیب تابع استفاده کنیم. به عنوان مثال، این عبارت را در نظر بگیرید:

```
sum (replicate 5 (max 6.7 8.9))
```

این عبارت را می‌توان به شکل زیر بازنویسی کرد:

```
(sum . replicate 5) max 6.7 8.9
```

که معادل زیر است:

```
sum . replicate 5 $ max 6.7 8.9
```

تابع replicate 5 بر روی نتیجه max 6.7 8.9 اعمال می‌شود و سپس تابع sum بر روی نتیجه حاصل از آن اعمال می‌شود. توجه کنید که ما تابع replicate را به طور جزئی باقی می‌گذاریم تا فقط یک پارامتر بپذیرد، به گونه‌ای که هنگامی که نتیجه max 6.7 8.9 به replicate 5 منتقل می‌شود، نتیجه آن لیستی از اعداد است که سپس به sum منتقل می‌شود.

اگر بخواهیم یک عبارت را با استفاده از ترکیب تابع و با حفظ خوانایی کد، بازنویسی کنیم، می‌توانیم با نوشتن تابع داخلی‌ترین تابع و پارامترهای آن شروع کنیم. سپس یک علامت $ جلوی آن قرار داده و تمام توابع قبلی را بدون آخرین پارامترشان نوشته و نقطه‌گذاری بین آن‌ها قرار دهیم. به عنوان مثال، فرض کنید می‌خواهیم این عبارت را بازنویسی کنیم:

```
replicate 2 (product (map (*3) (zipWith max [1,2] [4,5])))
```

می‌توانیم این عبارت را به صورت زیر نوشته شود:

```
replicate 2 . product . map (*3) $ zipWith max [1,2] [4,5]
```

چگونه از نسخه قبلی به این نسخه رسیدیم؟ خب، ابتدا به تابع سمت راست و پارامترهای آن قبل از دسته بندی پرانتز ها نگاه می‌کنیم. آن تابع zipWith max [1،2] [4،5] است. ما آن را به همان شکلی که هست باقی می‌گذاریم، بنابراین اکنون این را داریم:

```
zipWith max [1،2] [4،5]
```

سپس به تابعی که به zipWith max [1،2] [4،5] اعمال شده بود نگاه می‌کنیم و می‌بینیم که این تابع map (*3) بود. بنابراین یک $ بین آن و آنچه قبلاً داشتیم قرار می‌دهیم:

```
map (*3) $ zipWith max [1,2] [4,5]
```

حال شروع به ترکیب توابع می‌کنیم. بررسی می‌کنیم که کدام تابع در این همه اعمال به کار رفته است و می‌بینیم که تابع product بود، بنابراین آن را با map (*3) ترکیب می‌کنیم:

```
product . map (*3) $ zipWith max [1,2] [4,5]
```

و در نهایت، می‌بینیم که تابع replicate 2 به همه این عملیات اعمال شده است، و می‌توانیم عبارت را به صورت زیر بنویسیم:

```
replicate 2 . product . map (*3) $ zipWith max [1,2] [4,5]
```

اگر عبارت با سه پرانتز به پایان برسد، احتمالاً اگر به این روش آن را به ترکیب تابع ترجمه کنید، دو عملگر ترکیب در آن خواهد بود.


Point-Free Style


یکی دیگر از کاربردهای رایج ترکیب تابع، تعریف توابع به سبک Point-Free است. به عنوان مثال، یک تابع که قبلاً نوشته شده‌است، در نظر بگیرید:

```
sum' :: (Num a) => [a] -> a
sum' xs = foldl (+) 0 xs
```
الف xs در دو طرف علامت مساوی در سمت راست قرار دارد. به دلیل Curry، می‌توانیم این xs را در هر دو طرف حذف کنیم، زیرا فراخوانی foldl (+) 0 تابعی را ایجاد می‌کند که یک لیست را می‌پذیرد. به این صورت، ما تابع را به سبک Point-Free می‌نویسیم:

```
sum' :: (Num a) => [a] -> a
sum' = foldl (+) 0
```

به عنوان یک مثال دیگر، تابع زیر را به سبک Point-Free بنویسید:

```
fn x = ceiling (negate (tan (cos (max 50 x))))
```

ما نمی‌توانیم فقط x را در هر دو طرف راست حذف کنیم، زیرا x در بدنه تابع توسط پرانتزها احاطه شده است. cos(max 50) مفهومی ندارد، زیرا نمی‌توانید کسینوس یک تابع را دریافت کنید. آنچه که می‌توانیم انجام دهیم، بیان fn را به عنوان ترکیبی از توابع صورت بگیرانیم، مانند این:

```
fn = ceiling . negate . tan . cos . max 50
```

خیلی خوبه! بسیاری اوقات، استفاده از سبک Point-Free، خوانایی و مختصرتر است زیرا شما را به فکر توابع و نوع توابعی که به وسیله ترکیب آن‌ها ایجاد می‌شود می‌اندازد، به جای اینکه به داده‌ها و نحوه تغییر آن‌ها فکر کنید. شما می‌توانید توابع ساده را بگیرید و از ترکیب آن‌ها به عنوان چسب برای ایجاد توابع پیچیده‌تر استفاده کنید.
با این حال، اگر یک تابع بسیار پیچیده باشد، نوشتن آن در سبک Point-Free ممکن است کمتر خوانا باشد. به همین دلیل، ساخت زنجیره‌های طولانی از ترکیب توابع توصیه نمی‌شود. سبک اولویت داده شده استفاده از let bindings است تا برچسب‌هایی برای نتایج میانی بدهیم و یا مشکل را به زیر مسائل کوچک‌تر تقسیم کنیم که برای شخصی که کد را می‌خواند، قابل فهمتر باشد.
در ابتدای فصل، مشکل پیدا کردن مجموع تمام مربع‌های فرد کوچکتر از ۱۰۰۰۰ حل شد. وقتی این حل به عنوان یک تابع نوشته شود، به صورت زیر خواهد بود:

```
oddSquareSum :: Integer
oddSquareSum = sum (takeWhile (<10000) (filter odd (map (^2) [1..])))
```

با دانش ما از ترکیب توابع، همچنین می‌توانیم تابع را به این شکل هم بنویسیم:

```
oddSquareSum :: Integer
oddSquareSum = sum . takeWhile (<10000) . filter odd $ map (^2) [1..]
```

در ابتدا ممکن است کمی عجیب به نظر برسد، اما به سرعت با این سبک آشنا خواهید شد. با حذف پرانتزها، صدای بصری کمتری وجود دارد. در هنگام خواندن این کد، می‌توانید بگویید که filter odd بر روی نتیجه map (^2) [1..] اعمال می‌شود، سپس takeWhile (<10000) بر روی نتیجه آن اعمال شده و در نهایت sum بر روی آن نتیجه اعمال می‌شود.
