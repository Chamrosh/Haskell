اگر شما از آن دست افرادی هستید که مقدمات را نمی خوانند، احتمالاً باید به بخش قبلی بروید - آنجا توضیح داده شده است که چگونه از این کتاب استفاده کنید، و همچنین چگونه توابع را با `GHC` بارگذاری کنید.

برای شروع، اجرای تعاملی `GHC` را شروع کرده و برخی از توابع را فراخوانی کنید، تا بتوانید احساسی بسیار ابتدایی از `Haskell` پیدا کنید. یک ترمینال باز کرده و `ghci` را تایپ کنید. شما با چیزی شبیه به این روبرو خواهید شد:

```
GHCi, version 6.12.3: http://www.haskell.org/ghc/ :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
Loading package ffi-1.0 ... linking ... done.
NOTE
```
توجه؛ پیش‌فرض `GHCi` برای پرامپت `<Prelude` است، اما ما برای مثال‌های این کتاب از `<ghci` به عنوان پرامپت استفاده خواهیم کرد. برای تطبیق پرامپت خود با پرامپت کتاب، دستور `"<set prompt "gtci:` را در `GHCi` وارد کنید. اگر نمی‌خواهید هر بار که `GHCi` را اجرا می‌کنید این کار را انجام دهید، یک فایل با نام .ghci در پوشه خانه‌تان بسازید و محتویات آن را به `"<set prompt "gtci:`  تنظیم کنید.


تبریک می‌گویم، شما در `GHCi` هستید! حالا بیایید چند محاسبه ساده انجام دهیم.

```
ghci> 2 + 15
17
ghci> 49 * 100
4900
ghci> 1892 - 1472
420
ghci> 5 / 2
2.5
```

اگر چندین عملگر را در یک عبارت استفاده کنیم، `Haskell` آنها را با توجه به اولویت عملگرها اجرا می کند. به عنوان مثال، عملگر `*` اولویت بالاتری نسبت به `-` دارد، لذا `4999 - 100 * 50` به عنوان `4999 - (100 * 50)` در نظر گرفته می شود. ما همچنین می توانیم با استفاده از پرانتزها، ترتیب عملیات را به صورت صریح مشخص کنیم، مانند این:

```
ghci> (50 * 100) - 4999
1
ghci> 50 * 100 - 4999
1
ghci> 50 * (100 - 4999)
-244950
```

خیلی خفن نیست؟ (بله، می دانم هنوز اینطور نیست، اما با من باشید.)
یکی از معضلاتی که باید مراقب آن باشید، ثابت های عددی منفی است. بهتر است همیشه آنها را در هر جایی که در یک عبارت حسابی وجود دارند با پرانتزها احاطه کنید. به عنوان مثال، وارد کردن `3- *5 ` باعث می شود `GHCi` به شما بیخیالی کند، اما وارد کردن `(3-) * 5` به خوبی کار می کند.

جبر بولی نیز در `Haskell` ساده است. مانند بسیاری از زبان های برنامه نویسی دیگر، `Haskell` دارای مقادیر بولی `True` و `False` است و از عملگر `&&` برای اتصال (بولی و)، عملگر `||` برای انحصار (بولی یا) و عملگر `not` برای منفی کردن مقدار `True` یا `False` استفاده می کند:

```
ghci> True && False
False
ghci> True && True
True
ghci> False || True
True
ghci> not False
True
ghci> not (True && True)
False
```


ما می‌توانیم دو مقدار را با استفاده از عملگرهای `==` و `/=` برای بررسی برابری و عدم برابری آنها آزمایش کنیم، به این شکل:

```
ghci> 5 == 5
True
ghci> 1 == 0
False
ghci> 5 /= 5
False
ghci> 5 /= 4
True
ghci> "hello" == "hello"
True
```

اما هنگامی که ارزش‌ها را با هم ترکیب می‌کنیم، باید مواظب باشیم! اگر مانند `5 + "llama"` چیزی وارد کنیم، پیام خطای زیر را دریافت می‌کنیم:
```
No instance for (Num [Char])
arising from a use of `+' at <interactive>:1:0-9
Possible fix: add an instance declaration for (Num [Char])
In the expression: 5 + "llama"
In the definition of `it': it = 5 + "llama"
```

آنچه `GHCi` در اینجا به ما می‌گوید، این است که `"llama"` یک عدد نیست، بنابراین نمی‌داند چگونه آن را به `5` اضافه کند. عملگر `+` انتظار دارد که هر دو ورودی آن عدد باشند.
از طرف دیگر، عملگر `==` بر روی هر دو موردی که می‌توانند مقایسه شوند کار می‌کند، با یک مشکل: هر دو باید از نوع یکسان باشند. به عنوان مثال، اگر سعی کنیم `True == 5` را وارد کنیم، `GHCi` شکایت می‌کند.


توجه؛ عبارت `5 + 4.0` یک عبارت معتبر است، زیرا گرچه `4.0` یک عدد صحیح نیست، `5` زیرک است و می‌تواند مانند یک عدد صحیح یا یک عدد اعشاری عمل کند. در این حالت، `5` برای تطبیق با نوع مقدار اعشاری `4.0`، تطبیق می کند.

ما بعداً به صورت دقیق‌تر به انواع داده‌ها نگاه خواهیم کرد.



**فراخوانی توابع(Calling Functions‍)**

شاید متوجه نشده باشید، اما در واقع تمام این زمان از توابع استفاده کرده‌ایم. به عنوان مثال، `*` یک تابع است که دو عدد را دریافت کرده و آنها را در یکدیگر ضرب می‌کند. همانطور که دیده‌اید، ما آن را با قرار دادنش بین دو عددی که می‌خواهیم ضرب کنیم، اعمال (یا فراخوانی) می‌کنیم. این یک تابع نشانه‌ای نامیده می‌شود.

بیشتر توابع، با این حال، توابع نشانه‌ای هستند. هنگام فراخوانی توابع نشانه‌ای در `Haskell`، نام تابع اولین چیزی است که ظاهر می‌شود، سپس یک فاصله، سپس پارامترهای آن (نیز با فاصله از هم جدا شده). به عنوان مثال، ما تلاش می‌کنیم تا یکی از خسته کننده‌ترین توابع در `Haskell` به نام `succ`  را فراخوانی کنیم:

```
ghci> succ 8
9
```

تابع `succ` یک پارامتر را می گیرد که می تواند هر چیزی باشد که یک جانشین کاملاً تعریف شده دارد و آن مقدار را برمی گرداند. جانشین یک مقدار صحیح فقط عدد بالاتر بعدی است.

حالا بیایید دو تابع نشانه‌ای دیگر که چندین پارامتر دریافت می‌کنند، `min` و `max` را فراخوانی کنیم.
```
ghci> min 9 10
9
ghci> min 3.4 3.2
3.2
ghci> max 100 101
101
```

توابع `min` و `max` هر کدام دو پارامتر دریافت می‌کنند که می‌توانند به ترتیبی (مانند اعداد!) قرار داده شوند و به ترتیب کوچکترین یا بزرگترین مقدار را برمی‌گردانند.
برنامه تابع بالاترین اولویت را در بین تمام عملیات‌های `Haskell` دارد. به عبارت دیگر، این دو بیانیه معادل هستند.

```
ghci> succ 9 + max 5 4 + 1
16
ghci> (succ 9) + (max 5 4) + 1
16
```

این بدان معنی است که اگر می‌خواهیم جانشین `9 * 10` را بدست آوریم، نمی‌توانیم به سادگی بنویسیم:

```
ghci> succ 9 * 10
```

به دلیل اولویت عملیات، این به عنوان جانشین `9` (که `10` است) ضرب در `10`، و بازگرداندن `100`، ارزیابی می‌شود. برای بدست آوردن نتیجه مورد نظر، باید به جای آن، بنویسیم: 

```
ghci> succ (9 * 10)
```
این عبارت به ما `۹۱` را برمی‌گرداند.


اگر یک تابع دو پارامتری باشد، می‌توانیم آن را به عنوان یک تابع دوگانه فراخوانی کنیم با احاطه نام آن با علامت نقل قول برعکس ``` (`) ```. به عنوان مثال، تابع `div` دو عدد صحیح را دریافت می‌کند و یک تقسیم صحیح انجام می‌دهد، به صورت زیر:

```
ghci> div 92 10
9
```

با این حال، هنگامی که به این شکل آن را فراخوانی می‌کنیم، ممکن است برخی ابهام در مورد عددی که توسط کدام عدد تقسیم می‌شود وجود داشته باشد. با استفاده از علامت نقل قول برعکس، می‌توانیم آن را به عنوان یک تابع دوگانه فراخوانی کنیم و به طور ناگهانی بسیار شفاف تر خواهد شد:

```
ghci> 92 `div` 10
9
```

بسیاری از برنامه نویسانی که به زبان های دستوری عادت دارند، تمایل دارند به این مفهوم پایبند باشند که پرانتز باید کاربرد تابع را نشان دهد، و در تنظیم کردن با روش `Haskell` برای انجام کارها مشکل دارند. فقط به یاد داشته باشید، اگر چیزی شبیه نوار (نوار 3) مشاهده کردید، به این معنی است که ابتدا تابع نوار را با پارامتر 3 فراخوانی می کنیم، سپس آن نتیجه را دوباره به تابع نوار ارسال می کنیم. عبارت معادل در C چیزی شبیه bar(bar(3)) خواهد بود.



**توابع اولیه کودکان(Baby’s First Functions)**

نحو تعریف یک تابع شبیه به فراخوانی تابع است: نام تابع با پارامترهایی دنبال می شود که با فاصله از هم جدا می شوند. اما سپس لیست پارامترها توسط عملگر `=` دنبال می شود و کدی که بدنه تابع را تشکیل می دهد از آن پیروی می کند.
به عنوان مثال، یک تابع ساده‌ای را که یک عدد را در دو ضرب می‌کند، خواهیم نوشت. ویرایشگر متن مورد علاقه‌تان را باز کرده و متن زیر را تایپ کنید:

```
haskell
doubleMe x = x * 2
```

این فایل را با نام `baby.hs` ذخیره کنید. حالا `GHCi` را اجرا کنید و مطمئن شوید که فایل`baby.hs` در مسیر کنونی شما قرار دارد. پس از ورود به `GHCi`، دستور `l baby:` را برای بارگذاری فایل وارد کنید. حالا می‌توانیم با تابع جدیدمان بازی کنیم:

```
ghci> :l baby
[1 of 1] Compiling Main             ( baby.hs, interpreted )
Ok, modules loaded: Main.
ghci> doubleMe 9
18
ghci> doubleMe 8.3
16.6
```

زیرا `+` بر روی اعداد صحیح و اعداد اعشاری کار می‌کند (به واقع بر روی هر چیزی که می‌توان آن را یک عدد در نظر گرفت)، تابع ما همچنین با هر یک از این انواع کار می‌کند.
حالا بیایید یک تابع بسازیم که دو عدد را گرفته، هر یک را در دو ضرب کند و سپس آنها را باهم جمع کند. کد زیر را به `baby.hs` اضافه کنید:
```
haskell
doubleUs x y = x*2 + y*2
```
توجه: توابع در `Haskell` نیازی به تعریف به ترتیب خاصی ندارند، بنابراین این مهم نیست کدام تابع در فایل `baby.hs` شما اولین تابع باشد.

حالا فایل را ذخیره کرده و با وارد کردن دستور `l baby:` در `GHCi` تابع جدید خود را بارگذاری کنید.
تست این تابع نتایج قابل پیش‌بینی‌ای را به دنبال دارد:

```
ghci> doubleUs 4 9
26
ghci> doubleUs 2.3 34.2
73.0
ghci> doubleUs 28 88 + doubleMe 123
478
```

توابعی که شما تعریف می‌کنید، همچنین می‌توانند از یکدیگر فراخوانی شوند. با این در نظر، می‌توانیم تابع `doubleUs` را به روش زیر بازتعریف کنیم:

```
doubleUs x y = doubleMe x + doubleMe y
```

این یک مثال بسیار ساده از الگوی رایجی است که در زمان استفاده از `Haskell` مشاهده خواهید کرد: توابع ساده و بدون ابهام می‌توانند ترکیب شوند تا توابع پیچیده‌تری شکل بگیرند. این یک راه عالی برای جلوگیری از تکرار کد است. به عنوان مثال، چه اگر یک روز ریاضی‌دانان فهمیدند که `۲` و `۳` در واقع یکسان هستند، و شما باید برنامه خود را تغییر دهید؟ شما می‌توانید به راحتی `doubleMe` را به `x + x + x` تغییر دهید، و با توجه به اینکه `doubleUs` از `doubleMe` فراخوانی می‌شود، حالا به طور خودکار در این دنیای عجیب و غریب جدید که `۲` برابر `۳` است، به درستی کار خواهد کرد.

حالا بیایید یک تابع بنویسیم که یک عدد را در دو ضرب کند، اما فقط اگر آن عدد کوچکتر یا مساوی با `۱۰۰` باشد (زیرا اعداد بزرگتر از `۱۰۰` به اندازه کافی بزرگ هستند!).

```
doubleSmallNumber x = if x > 100
                        then x
                        else x*2
```


این مثال، `if statement` در `Haskell` را معرفی می‌کند. شما احتمالاً با `if statement` از زبان‌های دیگر آشنایی دارید، اما چیزی که `if statement` در `Haskell` را منحصر به فرد می‌کند، این است که بخش `else` آن اجباری است.
برنامه‌های زبان‌های دستوری در واقع یک سری مراحل هستند که کامپیوتر هنگام اجرای برنامه انجام می‌دهد. هنگامی که یک `if statement` وجود دارد که متناظر با آن بخش `else` وجود ندارد، و شرط برآورده نشود، مراحلی که در بخش `if` قرار دارند، اجرا نخواهند شد. بنابراین، در زبان‌های دستوری، یک`if statemen`می‌تواند هیچ کاری انجام ندهد.
از سوی دیگر، یک برنامه `Haskell`، مجموعه‌ای از توابع است. توابع برای تبدیل مقادیر داده‌ای به مقادیر نتیجه استفاده می‌شوند و هر تابع باید یک مقدار برگرداند که در نتیجه می‌تواند توسط یک تابع دیگر استفاده شود. از آنجا که هر تابع باید چیزی را برگرداند، این به معنای این است که هر `if` باید بخش متناظر با آن را داشته باشد. در غیر این صورت، می‌توانید یک تابع را بنویسید که در صورت برآورده شدن یک شرط، یک مقدار برگرداند، اما زمانی که آن شرط برآورده نشود، هیچ مقداری برنگرداند! به طور خلاصه: `if` در `Haskell` یک `expression` است که باید یک مقدار برگرداند و نه یک `statement`.

بیایید بگوییم که می‌خواهیم یک تابع بنویسیم که یک را به هر عددی که توسط تابع `doubleSmallNumber` ساخته می‌شود، اضافه کند. بدنه این تابع به شکل زیر خواهد بود:

```
doubleSmallNumber' x = (if x > 100 then x else x*2) + 1
```

توجه کنید که مکان قرار گیری پرانتزها بسیار مهم است. اگر آنها را حذف کرده بودیم، تابع فقط یک را به عددی که کوچکتر یا مساوی با `۱۰۰` است، اضافه می‌کرد. همچنین توجه کنید که نقطه‌ی تعجب (') در پایان نام تابع وجود دارد. نقطه‌ی تعجب در نحوه‌ی نوشتاری `Haskell` هیچ معنی خاصی ندارد، به این معنی که یک کاراکتر معتبر برای استفاده در نام تابع است. ما معمولاً نقطه‌ی تعجب را برای نشان دادن یک نسخه‌ی دقیق‌تر (یعنی یک نسخه‌ی که `lazy` نیست) از یک تابع، یا یک نسخه‌ی کمی تغییر یافته از یک تابع یا متغیر با نام مشابه استفاده می‌کنیم.

از آنجا که نقطه‌ی تعجب ' یک کاراکتر معتبر برای نام تابع است، می‌توانیم یک تابعی بنویسیم که به شکل زیر باشد:

```
conanO'Brien = "It's a-me, Conan O'Brien!"
```

در اینجا دو نکته وجود دارد. اول اینکه ما `Conan` را در نام تابع با حروف کوچک نوشته‌ایم. در `Haskell`، توابع نمی‌توانند با حروف بزرگ شروع شوند. (دلیل آن را بعداً خواهیم دید.) دومین نکته این است که این تابع هیچ پارامتری نمی‌گیرد. هنگامی که یک تابع هیچ پارامتری نمی‌گیرد، معمولاً آن را یک تعریف یا یک نام می‌نامیم. به دلیل اینکه ما نمی‌توانیم پس از تعریف یک نام (یا تابع)، معنی آن را تغییر دهیم، تابع `conanO'Brien` و رشته ``"It's a-me, Conan O'Brien!"`` به صورت قابل تعویضی قابل استفاده هستند.


**مقدمه‌ای درباره‌ی لیست‌ها(An Intro to Lists)**

لیست‌ها در `Haskell` ساختار داده‌های همگن هستند، به این معنی که چندین عنصر از یک نوع در آن‌ها ذخیره می‌شوند. ما می‌توانیم یک لیست از اعداد صحیح یا یک لیست از کاراکترها داشته باشیم، به عنوان مثال، اما نمی‌توانیم یک لیست از اعداد صحیح و کاراکترها داشته باشیم.

لیست‌ها با پرانتز مربعی محصور شده‌اند و مقادیر لیست با کاما جدا می‌شوند:

```
ghci> let lostNumbers = [4,8,15,16,23,42]
ghci> lostNumbers
[4,8,15,16,23,42]
```

توجه؛ از کلمه کلیدی `let` برای تعریف یک نام در `GHCi` استفاده کنید. وارد کردن `let a = 1` در `GHCi` معادل با نوشتن `a = 1` در یک اسکریپت است، سپس آن را با `l:` بارگیری می‌کنید.


**اتصال(Concatenation)**

یکی از رایج‌ترین عملیات هنگام کار با لیست‌ها، اتصال است. در `Haskell`، این با استفاده از اپراتور `++` انجام می‌شود:

```
ghci> [1,2,3,4] ++ [9,10,11,12]
[1,2,3,4,9,10,11,12]
ghci> "hello" ++ " " ++ "world"
"hello world"
ghci> ['w','o'] ++ ['o','t']
"woot"
```

توجه؛ در `Haskell`، رشته‌ها در واقع فقط لیستی از کاراکترها هستند. به عنوان مثال، رشته `"hello"` در واقع همان لیست ``['h'،'e'،'l'،'l'،'o']`` است. به دلیل این، ما می‌توانیم از توابع لیستی بر روی رشته‌ها استفاده کنیم که واقعاً مفید است.


هنگام استفاده مکرر از اپراتور `++` بر روی رشته‌های بلند، مواظب باشید. هنگامی که دو لیست را با هم ترکیب می‌کنید، `Haskell` باید از ابتدای لیست اول (لیستی که در سمت چپ از `++` قرار دارد) عبور کند. این مشکلی نیست وقتی با لیست‌های کوچک سر و کار دارید، اما اضافه کردن چیزی به انتهای یک لیست با پنجاه میلیون ورودی ممکن است مدتی طول بکشد.

با این حال، اضافه کردن چیزی به ابتدای یک لیست عملیات تقریباً فوری است. ما این کار را با استفاده از اپراتور `:` (همچنین به عنوان اپراتور `cons` نیز شناخته می‌شود) انجام می‌دهیم:

```
ghci> 'A':" SMALL CAT"
"A SMALL CAT"
ghci> 5:[1,2,3,4,5]
[5,1,2,3,4,5]
```

توجه کنید که در مثال اول، : یک کاراکتر و یک لیست از کاراکترها (یک رشته) را به عنوان آرگومان‌های خود دریافت می‌کند. به طور مشابه، در مثال دوم، : یک عدد و یک لیست از اعداد را دریافت می‌کند. اولین آرگومان اپراتور `:` همیشه باید یک مورد تکی از همان نوع باشد که مقادیر در لیستی که به آن اضافه می‌شود.

از طرف دیگر، اپراتور `++` همیشه دو لیست را به عنوان آرگومان دریافت می‌کند. حتی اگر شما فقط یک عنصر را به انتهای یک لیست با `++` اضافه کنید، همچنان باید آن عنصر را با پرانتز مربعی محصور کنید، تا `Haskell` آن را مانند یک لیست در نظر بگیرد:

```
ghci> [1,2,3,4] ++ [5]
[1,2,3,4,5]
```

نوشتن `[1،2،3،4] ++ 5` اشتباه است، زیرا هر دو پارامتر به `++` باید لیست باشند و `5` لیست نیست؛ بلکه یک عدد است.

به طور جالب، در هسکل، `[1،2،3]` فقط شکر نحوی برای `[]:1:2:3` است. `[]` یک لیست خالی است. اگر ما `3` را در ابتدای آن قرار دهیم، به `[3]` تبدیل می‌شود. سپس اگر `2` را در ابتدای آن قرار دهیم، به `[2،3]` تبدیل می‌شود و به همین ترتیب.

توجه؛ `[]، [[]]` و `[[], [], []]` همه چیزهای متفاوتی هستند. اولین آن لیست خالی است، دومین آن یک لیست است که یک لیست خالی را شامل می‌شود و سومین آن یک لیست است که سه لیست خالی را شامل می‌شود.


**دسترسی به المان‌های لیست(Accessing List Elements)**

اگر می خواهید یک عنصر از یک لیست را بر اساس شاخص دریافت کنید، از `!!` اپراتور. مانند بسیاری از زبان های برنامه نویسی، شاخص ها از 0 شروع می شوند:

```
ghci> "Steve Buscemi" !! 6
'B'
ghci> [9.4,33.2,96.2,11.2,23.25] !! 1
33.2
```

با این حال، اگر سعی کنید (مثلاً) ششمین عنصر را از یک لیست که تنها چهار عنصر دارد، بگیرید، خطایی دریافت می‌کنید، بنابراین مواظب باشید!


**لیست‌ها درون لیست‌ها(Lists Inside Lists)**

لیست‌ها می‌توانند شامل لیست‌هایی به عنوان عناصر باشند و لیست‌ها می‌توانند شامل لیست‌هایی باشند که لیست‌های دیگری را شامل می‌شوند و غیره... 

```
ghci> let b = [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci> b
[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci> b ++ [[1,1,1,1]]
[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3],[1,1,1,1]]
ghci> [6,6,6]:b
[[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci> b !! 2
[1,2,2,3,4]
```

لیست‌ها درون لیست‌ها ممکن است طول‌های متفاوتی داشته باشند، اما نمی‌توانند از انواع متفاوتی باشند. مانند اینکه نمی‌توانید یک لیستی را داشته باشید که برخی از کاراکترها و برخی از اعداد به عنوان عناصر داشته باشد، همچنین نمی‌توانید یک لیستی را داشته باشید که برخی از لیست‌های کاراکتری و برخی از لیست‌های عددی را شامل شود.


**مقایسه لیست‌ها(Comparing Lists)**

اگر مواردی که درون لیست‌ها قرار دارند قابل مقایسه باشند، لیست‌ها می‌توانند مقایسه شوند. هنگام استفاده از `<`، `<=`، `>=` و `>` برای مقایسه دو لیست، آن‌ها به ترتیب لغت‌نامه‌ای مقایسه می‌شوند. این بدان معنی است که ابتدا سرهای دو لیست مقایسه می‌شوند و اگر برابر باشند، عناصر دوم مقایسه می‌شوند. اگر عناصر دوم هم برابر باشند، عناصر سوم مقایسه می‌شوند و به همین ترتیب تا زمانی که عناصر متفاوت پیدا شوند. ترتیب دو لیست توسط ترتیب جفت اول از عناصر متفاوت تعیین می‌شود.

برای مثال، هنگامی که `[3،4،2] < [3،4،3]` را ارزیابی می‌کنیم، `Haskell` می‌بیند که 3 و 3 برابر هستند، بنابراین 4 و 4 را مقایسه می‌کند. این دو نیز برابر هستند، بنابراین 2 و 3 را مقایسه می‌کند. 2 کوچکتر از 3 است، بنابراین به نتیجه می‌رسد که لیست اول کوچکتر از لیست دوم است. همین موضوع برای `<=`، `>=` و `>` نیز صدق می‌کند.

```
ghci> [3,2,1] > [2,1,0]
True
ghci> [3,2,1] > [2,10,100]
True
ghci> [3,4,2] < [3,4,3]
True
ghci> [3,4,2] > [2,4]
True
ghci> [3,4,2] == [3,4,2]
True
```

همچنین، همیشه لیست غیر خالی بزرگتر از یک لیست خالی در نظر گرفته می‌شود. این باعث می‌شود ترتیب دو لیست در تمام موارد به خوبی تعریف شود، از جمله زمانی که یک لیست بخشی از لیست دیگر است.


**دیگر عملیات‌های لیست(More List Operations)**

در ادامه، تعدادی از توابع اصلی لیست آورده شده است، همراه با مثال‌های استفاده از آن‌ها.

تابع `head` یک لیست را می‌گیرد و سر آن، یا اولین عنصر آن را برمی‌گرداند:

```
ghci> head [5,4,3,2,1]
5
```

تابع `tail` یک لیست را می‌گیرد و دم آن را برمی‌گرداند. به عبارت دیگر، سر لیست را قطع می‌کند:

```
ghci> tail [5,4,3,2,1]
[4,3,2,1]
```

تابع `last` عنصر آخر یک لیست را برمی‌گرداند:

```
ghci> last [5,4,3,2,1]
1
```

تابع `init` یک لیست را می‌گیرد و همه چیز به جز آخرین عنصر آن را برمی‌گرداند:

```
ghci> init [5,4,3,2,1]
[5,4,3,2]
```

برای کمک به ما در تصور این توابع، می‌توانیم یک لیست را به عنوان یک هیولا تصور کنیم، مانند این:

اما اگر سعی کنیم سر یک لیست خالی را بگیریم، چه اتفاقی می‌افتد؟

```
ghci> head []
*** Exception: Prelude.head: empty list
```

این امر باعث می‌شود که برای ما از بین برود! اگر هیولا وجود نداشته باشد، سر ندارد. وقتی از `head`، `tail`، `last` و `init` استفاده می‌کنید، مراقب باشید که از آن‌ها در لیست‌های خالی استفاده نکنید. این خطا در زمان کامپایل قابل گرفتن نیست، بنابراین همیشه بهتر است از احتیاط‌های لازم برای جلوگیری از درخواست غلط عناصر از یک لیست خالی استفاده کنید.


تابع `length` یک لیست را می‌گیرد و طول آن را برمی‌گرداند:

```
ghci> length [5,4,3,2,1]
5
```

تابع `null` بررسی می‌کند که آیا یک لیست خالی است یا نه. اگر خالی بود، `True` را برمی‌گرداند، در غیر این صورت `False`.

```
ghci> null [1,2,3]
False
ghci> null []
True
```

تابع `reverse` یک لیست را برعکس می‌کند:

```
ghci> reverse [5,4,3,2,1]
[1,2,3,4,5]
```

تابع `take` یک عدد و یک لیست را می‌گیرد. این تابع تعداد مشخص شده‌ای از عناصر را از ابتدای لیست استخراج می‌کند، مانند این:

```
ghci> take 3 [5,4,3,2,1]
[5,4,3]
ghci> take 1 [3,9,3]
[3]
ghci> take 5 [1,2]
[1,2]
ghci> take 0 [6,6,6]
[]
```

اگر سعی کنیم بیشتر از تعداد عناصر موجود در لیست را بگیریم، هسکل فقط کل لیست را برمی‌گرداند. اگر صفر عنصر را بگیریم، لیست خالی را دریافت می‌کنیم.


تابع `drop` به همان شکل کار می‌کند، با این تفاوت که (حداکثر) تعداد مشخص شده‌ای از عناصر از ابتدای یک لیست را حذف می‌کند:

```
ghci> drop 3 [8,4,2,1,5,6]
[1,5,6]
ghci> drop 0 [1,2,3,4]
[1,2,3,4]
ghci> drop 100 [1,2,3,4]
[]
```

تابع `maximum` یک لیست از مواردی که می‌توانند در برخی از ترتیبات قرار داده شوند را می‌گیرد و بزرگترین عنصر را برمی‌گرداند. تابع `minimum` نیز مشابه است، اما کوچکترین مورد را برمی‌گرداند:

```
ghci> maximum [1,9,2,3,4]
9
ghci> minimum [8,4,2,1,5,6]
1
```

تابع `sum` یک لیست از اعداد را می‌گیرد و مجموع آن‌ها را برمی‌گرداند. تابع `product` یک لیست از اعداد را می‌گیرد و حاصلضرب آن‌ها را برمی‌گرداند:

```
ghci> sum [5,2,1,6,3,2,5,7]
31
ghci> product [6,2,1,2]
24
ghci> product [1,2,5,6,7,9,2,0]
0
```

تابع `elem` یک مورد و یک لیست از موارد را می‌گیرد و به ما می‌گوید که آیا آن مورد یک عنصر از لیست است یا خیر. این تابع معمولا به عنوان یک تابع نشانه‌ای استفاده می‌شود، زیرا به این شکل بهتر قابل خواندن است.

```
ghci> 4 `elem` [3,4,5,6]
True
ghci> 10 `elem` [3,4,5,6]
False
```

بازه‌های تگزاس (`Texas Ranges`)**

چه اتفاقی می‌افتد اگر به یک لیست نیاز داشته باشیم که شامل اعداد بین ۱ تا ۲۰ باشد؟ البته می‌توانیم همه‌ی آن‌ها را به صورت دستی تایپ کنیم، اما این یک راه‌حل برای آقایانی نیست که از زبان‌های برنامه‌نویسی خودشان عالی‌ترین عملکرد را می‌خواهند. به جای آن، از بازه‌ها استفاده خواهیم کرد. بازه‌ها برای ساختن لیست‌هایی از عناصری که می‌توانند شمرده شوند یا به ترتیب شماره‌گذاری شوند، استفاده می‌شوند.

به عنوان مثال، اعداد می‌توانند شمرده شوند: ۱، ۲، ۳، ۴ و غیره. حروف نیز می‌توانند شمرده شوند: الفبا یک شماره‌گذاری از حروف از حرف آ تا حرف ز است. اما نام‌ها نمی‌توانند شمرده شوند. (بعد از "جان" چه می‌آید؟ نمی‌دانم!)

برای ساختن یک لیست شامل همه‌ی اعداد طبیعی از `۱` تا `۲۰`، می‌توانید فقط `[1..20]` را تایپ کنید. در هسکل، این دقیقاً همان چیزی است که با تایپ کردن `[1،2،3،4،5،6،7،8،9،10،11،12،13،14،15،16،17،18،19،20]` به دست می‌آید. تنها تفاوت بین این دو این است که تایپ دستی توالی‌های شماره‌گذاری طولانی، احمقانه است.

در زیر چند مثال دیگر آمده است:

```
ghci> [1..20]
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
ghci> ['a'..'z']
"abcdefghijklmnopqrstuvwxyz"
ghci> ['K'..'Z']
"KLMNOPQRSTUVWXYZ"
```

همچنین می‌توانید گامی بین موارد در بازه خود تعیین کنید. اگر بخواهیم یک لیست از هر عدد زوج بین ۱ تا ۲۰ داشته باشیم یا هر سومین عدد بین ۱ تا ۲۰ را داشته باشیم، کافی است که دو عنصر اول را با یک کاما جدا کنیم و حد بالای خود را مشخص کنیم:

```
ghci> [2,4..20]
[2,4,6,8,10,12,14,16,18,20]
ghci> [3,6..20]
[3,6,9,12,15,18]
```

اگر چه محدوده ها با قدم ها خیلی راحت هستند، اما همیشه هوشمندانه عمل نمی کنند. به عنوان مثال، شما نمی توانید `[100..16 ,8 ,4 ,2 ,1]` را وارد کنید و انتظار داشته باشید تمامی توان های `2` که بزرگتر از `100` نیستند، دریافت کنید. برای یک چیز، تنها می توانید یک اندازه قدم واحد را مشخص کنید. همچنین، برخی از دنباله هایی که حسابی نیستند، نمی توانند با ارائه تنها چند عضو اول خود، به صورت یکتا مشخص شوند.

توجه: برای ساختن یک لیست با تمامی اعداد از `20` تا `1`، نمی توانید فقط `[20..1]` را تایپ کنید، بلکه باید `[1..20,19]` را تایپ کنید. زمانی که از یک محدوده بدون قدم (مانند `[1..20]`) استفاده می کنید، `Haskell` با یک لیست خالی شروع می کند و سپس عضو شروع را با یکی افزایش می دهد تا به عضو پایانی در محدوده برسد یا آن را بیشتر کند. بدلیل اینکه `20` در حال حاضر بزرگتر از `1` است، نتیجه فقط یک لیست خالی خواهد بود.

شما همچنین می توانید از محدوده ها برای ساختن لیست های بی نهایت با عدم تعیین یک حد بالا استفاده کنید. به عنوان مثال، بیایید یک لیست حاوی اولین `24` ضربیات `13` را بسازیم. یک راه برای انجام این کار به صورت زیر است:

```
ghci> [13,26..24*13]
[13,26,39,52,65,78,91,104,117,130,143,156,169,182,195,208,221,234,247,260,273,286,299,312]
```

اما در واقع یک راه بهتر وجود دارد - استفاده از یک لیست بی نهایت:

```
ghci> take 24 [13,26..]
[13,26,39,52,65,78,91,104,117,130,143,156,169,182,195,208,221,234,247,260,273,286,299,312]
```

زیرا `Haskell` تنبل است، این برنامه تلاش نمی کند تا لیست بی نهایت را در حالت کامل بررسی کند (که خوب است چرا که هرگز پایان نخواهد یافت). در عوض، منتظر خواهد ماند تا ببیند کدام عناصری از آن لیست بی نهایت شما نیاز دارید. در مثال بالا، می بیند که فقط اولین `24` عنصر را می خواهید و با خوشحالی اجابت می کند.

چند تابع دیگری که می توانند برای تولید لیست های بلند یا بی نهایت استفاده شوند عبارتند از:

تابع `cycle` که یک لیست را می گیرد و عناصر آن را به طور نامحدود تکرار می کند تا یک لیست بی نهایت شکل بگیرد. اگر نتیجه را نمایش دهید، برای همیشه ادامه خواهد داشت، بنابراین مطمئن شوید که آن را در جایی برش دهید:

```
ghci> take 10 (cycle [1,2,3])
[1,2,3,1,2,3,1,2,3,1]
ghci> take 12 (cycle "LOL ")
"LOL LOL LOL "
```

تابع `repeat` یک عنصر را به عنوان ورودی می گیرد و یک لیست بی نهایت از آن عنصر تولید می کند. این مانند چرخش یک لیست با فقط یک عنصر است:

```
ghci> take 10 (repeat 5)
[5,5,5,5,5,5,5,5,5,5]
```

تابع `replicate` یک راه آسانتر برای ساختن یک لیست تشکیل شده از یک مورد است. این طول لیست و موردی را که باید تکرار شود را به عنوان ورودی می گیرد، به صورت زیر:

```
ghci> replicate 3 10
[10,10,10]
```

یک نکته نهایی در مورد محدوده ها: وقتی از آنها با اعداد اعشاری استفاده می کنید، مواظب باشید! به دلیل اینکه اعداد اعشاری به طبیعت خود، تنها دقت محدودی دارند، استفاده از آنها در محدوده ها می تواند نتایج بسیار عجیب و غریبی را به دنبال داشته باشد، همانطور که در اینجا مشاهده می کنید:

```
ghci> [0.1، 0.3 .. 1]
[0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]
```


**من یک ترکیب لیست هستم.(I’m a List Comprehension)**


ترکیبات لیست یک روش برای فیلتر کردن، تبدیل و ترکیب لیست ها هستند. آنها بسیار شبیه به مفهوم ریاضی ترکیب های مجموعه ای هستند. ترکیب های مجموعه ای معمولاً برای ساخت مجموعه ها از مجموعه های دیگر استفاده می شوند. مثالی از یک ترکیب ساده مجموعه به شکل زیر است: `{2 · x | x ∈ N، x ≤ 10}`. دقت در دقیق بودن نحو بالا مهم نیست، مهم این است که این عبارت می گوید "تمام اعداد طبیعی کوچکتر یا مساوی با `10` را بگیرید، هر کدام را با `2` ضرب کنید و از این نتایج برای ایجاد یک مجموعه جدید استفاده کنید". اگر می خواستیم همان چیزی را در `Haskell` بنویسیم، می توانیم با استفاده از عملیات لیست، چیزی شبیه به این بنویسیم: `take 10 [2،4..]`. با این حال، می توانیم همان کار را با استفاده از ترکیبات لیست انجام دهیم، مانند این:

```
ghci> [x*2 | x <- [1..10]]
[2,4,6,8,10,12,14,16,18,20]
```

بیایید به دقت ترکیب لیست در این مثال را بررسی کنیم تا نحو ترکیبات لیست را بهتر بفهمیم.
در `[x * 2 | x <- [1..10]]`، ما می گوییم که عناصر خود را از لیست `[1..10]` برمی داریم. `[x <- [1..10]]` به این معنی است که x مقدار هر عنصر را که از `[1..10]` برداشته شده است، برمی گیرد. به عبارت دیگر، ما هر عنصر از `[1..10]` را به `x` متصل می کنیم. بخش قبل از خط عمودی `(|)`، خروجی ترکیب لیست است. خروجی بخشی است که در آن مشخص می کنیم که چگونه می خواهیم عناصری که برداشته ایم در لیست نتیجه نهایی بازتاب داده شوند. در این مثال، ما می گوییم که می خواهیم هر عنصری که از لیست `[1..10]` برداشته شده است، دو برابر شود.


این ممکن است نسبت به مثال اول طولانی‌تر و پیچیده‌تر به نظر برسد، اما اگر بخواهیم کاری پیچیده‌تر از تنها ضرب این اعداد را انجام دهیم، از فهرست‌های ترکیبی واقعاً استفاده می‌کنیم.
به عنوان مثال، بیایید یک شرط (همچنین با نام پیش‌فرض) به ترکیب ما اضافه کنیم. پیش‌فرض‌ها در انتهای فهرست ترکیبی قرار می‌گیرند و با یک کاما از بقیه فهرست ترکیبی جدا می‌شوند. بیایید بگوییم ما فقط می‌خواهیم عناصری را که بعد از ضرب در دو، بزرگتر یا مساوی با `12` باشند، داشته باشیم:

```
ghci> [x*2 | x <- [1..10], x*2 >= 12]
[12,14,16,18,20]
```

اگر می‌خواهیم تمامی اعدادی را از `50` تا `100` که باقی‌مانده آنها در تقسیم بر `7` برابر با `3` است، داشته باشیم، به راحتی می‌توانیم به این شکل عمل کنیم:

```
ghci> [ x | x <- [50..100], x `mod` 7 == 3]
[52,59,66,73,80,87,94]
```

یک نکته: حذف بخش‌هایی از فهرست با استفاده از پیش‌فرض‌ها نیز با نام فیلترینگ شناخته می‌شود.
حال برای مثال دیگر، فرض کنید می‌خواهیم یک ترکیب ایجاد کنیم که هر عدد فردی بزرگتر از `10` را با `"BANG!"` و هر عدد فردی کوچکتر از `10` را با `"BOOM!"` جایگزین کند. اگر یک عدد زوج است، آن را از لیست خود حذف می‌کنیم. برای راحتی، این ترکیب را درون یک تابع قرار می‌دهیم تا بتوانیم به راحتی از آن استفاده کنیم:

```
boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]
```


نکته: به یاد داشته باشید، اگر سعی می‌کنید این تابع را در `GHCi` تعریف کنید، باید قبل از نام تابع یک `let` را قرار دهید. با این حال، اگر این تابع را درون یک اسکریپت تعریف کرده و سپس آن را در `GHCi` بارگذاری کنید، نیازی به این کار ندارید.
تابع `odd` در صورت ورودی دادن یک عدد فردی، `True` را برمی‌گرداند و در غیر این صورت، `False`. عنصر تنها در لیست قرار داده می‌شود اگر همه پیش‌فرض‌ها به `True` برسند.

```
ghci> boomBangs [7..13]
["BOOM!","BOOM!","BANG!","BANG!"]
```

می‌توانیم تعداد نامحدودی پیش‌فرض در ترکیب خود قرار دهیم، همه با کاما از هم جدا شده‌اند. به عنوان مثال، اگر می‌خواستیم تمامی اعداد از `10` تا `20` را که `13`، `15` یا `19` نیستند، داشته باشیم، به این شکل عمل می‌کنیم:

```
ghci> [ x | x <- [10..20], x /= 13, x /= 15, x /= 19]
[10,11,12,14,16,17,18,20]
```


نه تنها ما می‌توانیم چندین شرط در فهم لیست داشته باشیم ، بلکه ما همچنین می‌توانیم ارزش‌ها را از چندین لیست برداریم. هنگام برداشتن ارزش‌ها از چندین لیست ، هر ترکیبی از عناصر از این لیست‌ها در لیست نتیجه‌ای بازتاب داده می‌شود:
```
ghci> [x+y | x <- [1,2,3], y <- [10,100,1000]]
[11,101,1001,12,102,1002,13,103,1003]
```

در اینجا ، x از `[1، 2، 3]` برداشته شده است و y از `[10، 100، 1000]` برداشته شده است. این دو لیست به این شکل ترکیب می‌شوند. ابتدا ، x به 1 تبدیل می‌شود و در حالی که x 1 است ، y هر مقدار را از `[10، 100، 1000]` به خود می‌گیرد. به دلیل اینکه خروجی فهم لیست x + y است ، مقادیر 11، 101 و 1001 به ابتدای لیست نتیجه‌ای اضافه می‌شوند (1 به 10، 100 و 1000 اضافه می‌شود). بعد از آن ، x به 2 تبدیل می‌شود و همان اتفاقی که در آن رخ می‌دهد ، باعث اضافه شدن عناصر 12 ، 102 و 1002 به لیست نتیجه‌ای می‌شود. همین اتفاق وقتی x مقدار 3 را برمی‌گزیند رخ می‌دهد. به این ترتیب ، هر عنصر x از `[1، 2، 3]` با هر عنصر y از `[10، 100، 1000]` به همه روش‌های ممکن ترکیب می‌شود و x + y برای ساختن لیست نتیجه‌ای از آن ترکیبات استفاده می‌شود.
در ادامه مثال دیگری را بررسی می‌کنیم: اگر دو لیست `[2، 5، 10]` و `[8، 10، 11]` داشته باشیم و ما می‌خواهیم حاصلضرب تمام ترکیب‌های ممکن اعداد در این لیست‌ها را بگیریم ، می‌توانیم از فهم لیست زیر استفاده کنیم:

```
ghci> [x * y | x <- [2, 5, 10], y <- [8, 10, 11]]
[16,20,22,40,50,55,80,100,110]
```

همانطور که انتظار می‌رفت ، طول لیست جدید 9 است. حال ، اگر می‌خواستیم تمام حاصلضرب‌های ممکنی را که بیشتر از 50 هستند ، بگیریم چه اتفاقی می‌افتد؟ ما می‌توانیم فقط شرط دیگری را اضافه کنیم:

```
ghci> [ x*y | x <- [2,5,10], y <- [8,10,11], x*y > 50]
[55,80,100,110]
```

برای خنده دار کردن ، بیایید یک فهم لیست بسازیم که یک لیست صفت و یک لیست اسم را ترکیب می‌کند.

```
ghci> let nouns = ["hobo","frog","pope"]
ghci> let adjectives = ["lazy","grouchy","scheming"]
ghci> [adjective ++ " " ++ noun | adjective <- adjectives, noun <- nouns]
["lazy hobo","lazy frog","lazy pope","grouchy hobo","grouchy frog",
"grouchy pope","scheming hobo","scheming frog","scheming pope"]
```

حتی می‌توانیم از فهم لیست برای نوشتن نسخه خودمان از تابع طول استفاده کنیم! آن را length' خواهیم نامید. این تابع هر المان را در یک لیست با 1 جایگزین می‌کند ، سپس همه آنها را با تابع sum جمع می‌کند و طول لیست را برمی‌گرداند.

```
length' xs = sum [1 | _ <- xs]
```

ما ارزش‌ها را از لیست ورودی برمی‌داریم ، چون در واقع به ارزش‌ها اهمیتی نمی‌دهیم.
به یاد داشته باشید ، رشته‌ها نیز لیست‌ها هستند ، بنابراین می‌توانیم از فهم لیست برای پردازش و تولید رشته‌ها استفاده کنیم. در ادامه نمونه‌ای از یک تابع را می‌بینیم که یک رشته را دریافت می‌کند و تمام حروف کوچک آن را حذف می‌کند:

```
removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]
```

شرط در اینجا کل کار را انجام می‌دهد. این شرط می‌گوید که حرف فقط در صورتی در لیست جدید قرار می‌گیرد که عنصری از لیست `['A'..'Z']` باشد. ما می‌توانیم تابع را در GHCi بارگذاری کرده و آن را تست کنیم:

```
ghci> removeNonUppercase "Hahaha! Ahahaha!"
"HA"
ghci> removeNonUppercase "IdontLIKEFROGS"
"ILIKEFROGS"
```

همچنین می‌توانید فهم لیست تو در تو را ایجاد کنید اگر با لیست‌هایی که حاوی لیست‌هایی هستند ، کار می‌کنید. به عنوان مثال ، بیایید یک لیست که شامل چندین لیست از اعداد است را بگیریم و تمام اعداد فرد را بدون تغییر لیست حذف کنیم:

```
ghci> let xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]]
ghci> [ [ x | x <- xs, even x ] | xs <- xxs]
[[2,2,4],[2,4,6,8],[2,4,2,6,2,6]]
```

در اینجا خروجی فهم لیست بیرونی یک فهم لیست دیگر است. همیشه یک فهم لیست منجر به یک لیست از چیزی می‌شود ، لذا می‌دانیم که نتیجه در اینجا یک لیست از لیست‌های اعداد خواهد بود.

توجه: شما می‌توانید فهم لیست را در چند خط تقسیم کنید تا خوانایی آن را بهبود بخشید. اگر در GHCi نیستید ، این می‌تواند به شما کمک زیادی کند ، به ویژه زمانی که با فهم لیست‌های تو در تو سروکار دارید.


**تاپل‌ها (Tuples)**

تاپل‌ها برای ذخیره چندین عنصر متفاوت به عنوان یک مقدار واحد استفاده می‌شوند.
در برخی جهات ، تاپل‌ها شبیه لیست‌ها هستند. با این حال ، تفاوت‌های اساسی وجود دارد. اولاً ، همانطور که گفته شد ، تاپل‌ها ناهمگن هستند. این بدان معناست که یک تاپل می‌تواند عناصری از چندین نوع مختلف را ذخیره کند. دوماً ، تاپل‌ها اندازه ثابتی دارند ، به عبارت دیگر ، شما باید قبل از ذخیره کردن عناصر بدانید چند عنصر را ذخیره خواهید کرد.


تاپل‌ها با پرانتز محاط شده‌اند و اجزای آنها با کاما از هم جدا شده‌اند:

```
ghci> (1, 3)
(1,3)
ghci> (3, 'a', "hello")
(3,'a',"hello")
ghci> (50, 50.4, "hello", 'b')
(50,50.4,"hello",'b')
```

ا**ستفاده از تاپل‌ها (Using Tuples)**

برای نمونه ای از زمانی که تاپل‌ها مفید هستند ، بیایید در مورد اینکه چگونه یک بردار دو بعدی را در `Haskell` نمایش دهیم فکر کنیم. یک راه این استفاده از یک لیست دو موردی با فرم `[x،y]` است. اما فرض کنید می‌خواهیم یک لیست از بردارها را بسازیم ، تا گوشه‌های یک شکل دو بعدی را در صفحه مختصات نشان دهیم. ما می‌توانیم فقط یک لیست از لیست‌ها را مانند این بسازیم: `[[1,2],[8,11],[4,5]]`.
مشکل با این روش ، این است که ما می‌توانیم همچنین یک لیست مانند `[[1,2],[8,11,5],[4,5]]` بسازیم و سعی کنیم آن را به جای یک لیست از بردارها استفاده کنیم. با اینکه به عنوان یک لیست از بردارها معنا ندارد ، اما `Haskell` با این لیست در هرجایی که لیست قبلی هست ، مشکلی ندارد زیرا هر دو نوع (یک لیست از لیست‌های اعداد) هستند. این ممکن است باعث شود توابع برای کنترل بردارها و اشکال دو بعدی پیچیده‌تر شود.
در مقابل ، تاپل با اندازه دو (همچنین به عنوان جفت نامیده می‌شود) و تاپل با اندازه سه (همچنین به عنوان سه‌تایی نامیده می‌شود) به عنوان دو نوع متمایز در نظر گرفته می‌شوند ، که به این معناست یک لیست نمی‌تواند از جفت و سه‌تایی‌ها تشکیل شده باشد. این باعث می‌شود تاپل‌ها برای نمایش بردارها بسیار مفید باشند.
ما می‌توانیم بردارهای خود را با محاط کردن آنها با پرانتز به جای براکت مربعی تغییر دهیم ، مانند این: `[(1،2)،(8،11)،(4،5)]`. حالا ، اگر سعی کنیم جفت و سه‌تایی را ترکیب کنیم ، خطا دریافت می‌کنیم ، مانند این:

```
ghci> [(1,2),(8,11,5),(4,5)]
Couldn't match expected type `(t, t1)'
against inferred type `(t2, t3, t4)'
In the expression: (8, 11, 5)
In the expression: [(1, 2), (8, 11, 5), (4, 5)]
In the definition of `it': it = [(1, 2), (8, 11, 5), (4, 5)]
```



در `Haskell` ، تاپل‌هایی که همان طول را دارند اما شامل انواع داده‌ای مختلف هستند ، به عنوان انواع متمایزی از تاپل در نظر گرفته می‌شوند. به عنوان مثال ، شما نمی‌توانید یک لیست از تاپل‌هایی مانند `[(One",2"),(1,2)]` بسازید ، زیرا اولین تاپل یک جفت از اعداد است و دومین تاپل یک جفت حاوی یک رشته و سپس یک عدد است.
تاپل‌ها می‌توانند برای نمایش آسان انواع مختلفی از داده‌ها استفاده شوند. به عنوان مثال ، اگر بخواهیم نام و سن یک شخص را در `Haskell` نمایش دهیم ، می‌توانیم از یک سه‌تایی استفاده کنیم: `(Christopher", "Walken", 55")`.

به یاد داشته باشید ، تاپل‌ها از اندازه ثابتی برخوردار هستند - شما باید فقط زمانی از آنها استفاده کنید که قبل از ذخیره کردن عناصر بدانید چند عنصر نیاز دارید. دلیل اینکه تاپل‌ها به این شکل به طور سختگیرانه مورد استفاده قرار می‌گیرند این است که همانطور که گفته شد ، اندازه یک تاپل به عنوان بخشی از نوع آن در نظر گرفته می‌شود. متأسفانه ، این بدان معناست که شما نمی‌توانید یک تابع عمومی برای اضافه کردن یک عنصر به یک تاپل بنویسید - شما باید یک تابع برای اضافه کردن به یک جفت بنویسید (برای تولید یک سه‌تایی) ، یکی دیگر برای اضافه کردن به یک سه‌تایی (برای تولید یک چهارتایی) ، یکی دیگر برای اضافه کردن به یک چهارتایی و غیره.

مانند لیست‌ها ، تاپل‌ها می‌توانند با یکدیگر مقایسه شوند اگر اجزای آنها قابل مقایسه باشند. با این حال ، برخلاف لیست‌ها ، شما نمی‌توانید دو تاپل از اندازه‌های مختلف را مقایسه کنید.
اگرچه لیست‌های تک عنصری وجود دارند ، اما چیزی به نام تاپل تک عنصری وجود ندارد. این منطقی است زیرا ویژگی‌های یک تاپل تک عنصری به سادگی ویژگی‌های مقدار داخلی آن خواهد بود ، بنابراین تمایز دادن یک نوع جدید به ما هیچ فایده‌ای نخواهد داد.


**استفاده از جفت‌ها (Using Pairs)**

ذخیره داده در جفت‌ها در `Haskell` بسیار رایج است و تابع‌های مفیدی برای کنترل آنها وجود دارد. در زیر دو تابع که بر روی جفت‌ها عمل می‌کنند آمده است:
•
تابع `fst` یک جفت را می‌گیرد و اولین عنصر آن را برمی‌گرداند:
```
ghci> fst (8, 11)
8
ghci> fst ("Wow", False)
"Wow"
```

تابع `snd` یک جفت را می‌گیرد و — سورپرایز! — دومین عنصر آن را برمی‌گرداند:

```
ghci> snd (8, 11)
11
ghci> snd ("Wow", False)
False
```

توجه کنید که این توابع فقط بر روی جفت‌ها عمل می‌کنند. آنها بر روی سه‌تایی‌ها، چهارتایی‌ها، پنج‌تایی‌ها و غیره کار نمی‌کنند. ما بعداً به استخراج داده از تاپل‌ها به روش‌های مختلف می‌پردازیم.
تابع `zip` یک روش خوب برای تولید یک لیست از جفت‌ها است. این تابع دو لیست را می‌گیرد ، سپس با ترکیب عناصر متناظر آنها ، آنها را به یک لیست می‌پیوندد. این یک تابع بسیار ساده است ، اما می‌تواند بسیار مفید باشد زمانی که می‌خواهید دو لیست را به یک روش خاص ترکیب کنید یا همزمان دو لیست را پیمایش کنید. در زیر یک نمونه آمده است:

```
ghci> zip [1,2,3,4,5] [5,5,5,5,5]
[(1,5),(2,5),(3,5),(4,5),(5,5)]
ghci> zip [1..5] ["one", "two", "three", "four", "five"]
[(1,"one"),(2,"two"),(3,"three"),(4,"four"),(5,"five")]
```

توجه کنید که به دلیل اینکه جفت‌ها می‌توانند شامل انواع مختلف باشند ، `zip` می‌تواند دو لیست را که شامل عناصر انواع مختلفی هستند ، بگیرد. اما اگر اندازه لیست‌ها با هم مطابقت نداشته باشد چه اتفاقی می‌افتد؟

```
ghci> zip [5,3,2,6,2,7,2,5,4,6,6] ["im","a","turtle"]
[(5,"im")،(3,"a")،(2,"turtle")]
```

همانطور که در مثال بالا مشاهده می‌کنید ، تنها بخشی از لیست بلندتر استفاده می‌شود و بقیه ساده‌ترین حالت نادیده گرفته می‌شود. و به دلیل استفاده از ارزیابی تنبل ، ما می‌توانیم حتی لیست‌های محدود را با لیست‌های بی‌نهایت `zip` کنیم:

```
ghci> zip [1..] ["apple", "orange", "cherry", "mango"]
[(1,"apple")،(2,"orange")،(3,"cherry")،(4,"mango")]
```

در این مسئله، از تاپل‌ها و `comprehension` لیست استفاده می‌کنیم تا یک مثلث قائم‌الزاویه پیدا کنیم که شرایط زیر را برآورده می‌کند:
• طول سه ضلع عدد صحیحی است.
• طول هر ضلع کمتر یا مساوی با ۱۰ است.
• محیط مثلث (جمع طول سه ضلع) برابر با ۲۴ است.

یک مثلث قائم‌الزاویه، اگر یکی از زوایایش زاویه‌ی قائمه باشد (یعنی زاویه‌ای با اندازه ۹۰ درجه)، می‌باشد. مثلث‌های قائم‌الزاویه، دارای خاصیت مفیدی هستند که اگر مربع طول ضلع‌هایی که در زاویه‌ی قائمه قرار دارند را محاسبه کرده و آنها را جمع کنیم، مجموع آن با مربع ضلع مقابل زاویه‌ی قائمه برابر است. در شکل، ضلع‌هایی که در کنار زاویه‌ی قائمه قرار دارند، با a و b نشان داده شده‌اند و ضلع مقابل زاویه‌ی قائمه با c نشان داده می‌شود. این ضلع را هیپوتنوز می‌نامیم.

برای شروع، بیایید تمام ترایپل‌های ممکن را با عناصری کمتر یا مساوی با ۱۰ بسازیم:

```
ghci> let triples = [ (a,b,c) | c <- [1..10], a <- [1..10], b <- [1..10] ]
```

ما از سه لیست در سمت راست `comprehension` استفاده می‌کنیم و عبارت خروجی در سمت چپ آنها را به یک لیست از ترایپل‌ها ترکیب می‌کند. اگر ترایپل‌ها را در `GHCi` ارزیابی کنید، یک لیست `۱۰۰۰` موردی را دریافت خواهید کرد که طولانی است، بنابراین ما آن را در اینجا نمایش نمی‌دهیم.

سپس، ما ترایپل‌هایی را که مثلث‌های قائم‌الزاویه را نشان نمی‌دهند، با اضافه کردن یک شرط که بررسی می‌کند آیا قانون پیتاگوراس `(a^2 + b^2 == c^2)` برقرار است، فیلتر می‌کنیم. همچنین، تابع را به گونه‌ای تغییر می‌دهیم که اطمینان حاصل شود که ضلع a بزرگتر از هیپوتنوز c و ضلع b بزرگتر از ضلع a نباشد:

```
ghci> let rightTriangles = [ (a,b,c) | c <- [1..10], a <- [1..c], b <- [1..a], a^2 + b^2 == c^2]
```

توجه کنید که ما با تغییر محدوده‌ها در لیست‌هایی که مقادیر از آنها برمی‌گیریم، مقادیر ناکارآمد را بررسی نمی‌کنیم، مانند ترایپل‌هایی که ضلع b بزرگتر از هیپوتنوز هستند (در مثلث قائم‌الزاویه، هیپوتنوز همیشه بلندترین ضلع است). همچنین فرض کردیم که ضلع b هرگز بزرگتر از ضلع a نیست. این مشکلی را به وجود نمی‌آورد، زیرا برای هر ترایپل `(a،b،c)` با `a^2 + b^2 == c^2` و `b > a` که از بررسی خارج شده است، ترایپل `(b،a،c)` در نظر گرفته شده است و همان مثلث است، فقط با تغییر مکان دو پایه. (در غیر این صورت، لیست نتایج ما شامل جفت مثلث‌هایی خواهد بود که در واقع همان مثلث‌هایی هستند.)

توجه: در GHCi، شما نمی توانید تعاریف و عبارات را در چندین خط شکست دهید. با این حال، در این کتاب، گاهی اوقات باید یک خط را شکست دهیم تا کد بتواند در صفحه جا شود. (در غیر این صورت، کتاب باید بسیار پهن باشد و روی هیچ قفسه‌ی عادی نخواهد گذشت - و سپس شما باید قفسه‌های بزرگتری بخرید!)

تقریباً تمام شد. حالا، ما فقط باید تابع را به گونه‌ای تغییر دهیم که فقط مثلث‌هایی را که محیط آنها برابر با ۲۴ است، خروجی دهیم:

```
ghci> let rightTriangles' = [ (a,b,c) | c <- [1..10], a <- [1..c], b <- [1..a], a^2 + b^2 == c^2, a+b+c == 24]
ghci> rightTriangles'
[(6,8,10)]
```

و پاسخ ما در اینجاست! این یک الگوی رایج در برنامه‌نویسی تابعی است: شما با یک مجموعه مشخصی از راه حل‌های کاندید شروع می‌کنید و به ترتیب تبدیلات و فیلترها را بر روی آنها اعمال می‌کنید، تا ممکن است به یک راه حل (یا چندین راه حل) که به دنبال آن هستید، محدود شوید.

